#smdl

import ::math::lerp;

export enum gamma_mode { gamma_default = 0, gamma_linear = 0, gamma_srgb = 1 };

@(pure macro)
auto decodeSRGB(const auto texel) = #pow(texel, 2.2);

@(pure macro)
float4 applyGamma(const int gamma, const float4 texel) = gamma == int(gamma_srgb) ? float4(decodeSRGB(texel.rgb), texel.a) : texel;

@(pure macro)
float3 applyGamma(const int gamma, const float3 texel) = gamma == int(gamma_srgb) ? decodeSRGB(texel) : texel;

@(pure macro)
float2 applyGamma(const int gamma, const float2 texel) = gamma == int(gamma_srgb) ? decodeSRGB(texel) : texel;

@(pure macro)
float applyGamma(const int gamma, const float texel) = gamma == int(gamma_srgb) ? decodeSRGB(texel) : texel;

@(pure macro)
int getTileIndex(const texture_2d tex, const int2 uv_tile) {
  return -1 if (#any((uv_tile < 0) | (uv_tile >= tex.tile_count)));
  return uv_tile.y * tex.tile_count.x + uv_tile.x;
}

@(pure macro)
export int width(const texture_2d tex, const int2 uv_tile = int2(0)) {
  const auto i(getTileIndex(tex, uv_tile));
  return i < 0 ? 0 : tex.tile_extents[i].x;
}

@(pure macro)
export int width(const texture_3d tex) = 0; // TODO

@(pure macro)
export int width(const texture_cube tex) = 0; // TODO

@(pure macro)
export int height(const texture_2d tex, const int2 uv_tile = int2(0)) {
  const auto i(getTileIndex(tex, uv_tile));
  return i < 0 ? 0 : tex.tile_extents[i].y;
}

@(pure macro)
export int height(const texture_3d tex) = 0; // TODO

@(pure macro)
export int height(const texture_cube tex) = 0; // TODO

@(pure macro)
export bool texture_isvalid(const texture_2d tex) = bool(tex.tile_buffers[0]);

@(pure macro)
export bool texture_isvalid(const texture_3d tex) = false; // TODO

@(pure macro)
export bool texture_isvalid(const texture_cube tex) = false; // TODO

@(pure macro)
export bool texture_isvalid(const texture_ptex tex) = bool(tex.ptr);

@(pure)
auto texel_fetch(const texture_2d tex, const int2 coord, const int2 uv_tile = int2(0)) {
  const auto texel_type(*#typeof(tex.tile_buffers[0]));
  const auto i(getTileIndex(tex, uv_tile));
  return texel_type(0) if (i < 0);
  const auto tileExtent(tex.tile_extents[i]);
  const auto tileBuffer(tex.tile_buffers[i]);
  return texel_type(0) if (!tileBuffer | #any((coord < 0) | (coord >= tileExtent)));
  return tileBuffer[coord.y * tileExtent.x + coord.x];
}

@(pure macro)
export float4 texel_float4(const texture_2d tex, const int2 coord, const int2 uv_tile = int2(0)) {
  return applyGamma(tex.gamma, #unpack_float4(texel_fetch(tex, coord, uv_tile)));
}

@(pure macro)
export float3 texel_float3(const texture_2d tex, const int2 coord, const int2 uv_tile = int2(0)) {
  return applyGamma(tex.gamma, #unpack_float4(texel_fetch(tex, coord, uv_tile)).xyz);
}

@(pure macro)
export float2 texel_float2(const texture_2d tex, const int2 coord, const int2 uv_tile = int2(0)) {
  return applyGamma(tex.gamma, #unpack_float4(texel_fetch(tex, coord, uv_tile)).xy);
}

@(pure macro)
export float texel_float(const texture_2d tex, const int2 coord, const int2 uv_tile = int2(0)) {
  return applyGamma(tex.gamma, #unpack_float4(texel_fetch(tex, coord, uv_tile)).x);
}

@(pure macro)
export color texel_color(const texture_2d tex, const int2 coord, const int2 uv_tile = int2(0)) {
  return color(texel_float3(tex, coord, uv_tile));
}

export enum wrap_mode { wrap_clamp = 0, wrap_repeat = 1, wrap_mirrored_repeat = 2, wrap_clip = 3 };

@(pure macro)
auto applyWrap(const auto wrap, const auto n, auto i) {
  auto rem(i % n);
  const auto neg(#select(rem < 0, 1, 0));
  rem += n * neg;
  const auto quo(i / n + neg);
  const auto repeat(rem);
  const auto mirror(#select((quo & 1) == 1, n - 1 - rem, rem));
  i = #select(wrap == 0, i, #select(wrap == 1, repeat, mirror));
  i = #max(0, #min(i, n - 1));
  return i;
}

@(pure)
export float4 lookup_float4(
  const texture_2d tex,
  float2 coord,
  const wrap_mode wrap_u = wrap_repeat,
  const wrap_mode wrap_v = wrap_repeat,
  const float2 crop_u = float2(0.0, 1.0),
  const float2 crop_v = float2(0.0, 1.0),
) {
  if ((tex.tile_count.x > 1) | (tex.tile_count.y > 1)) {
    // MDL specification:
    // The wrap mode and crop parameters are ignored if the texture references a uv-tileset. In this case,
    // floor(coord) defines the index to select the tile in the uv-tileset and coord-floor(coord) defines the
    // uv coordinates to look up the sampled texture value in the normalized texture space in the range [0,1)^2
    // for the selected tile.
    const int2 tileIndex(#floor(coord));
    const auto i(getTileIndex(tex, tileIndex));
    return float4(0) if (i < 0);
    const auto tileExtent(tex.tile_extents[i]);
    const auto tileBuffer(tex.tile_buffers[i]);
    return float4(0) if (!tileBuffer);
    coord -= tileIndex;
    coord *= tileExtent;
    coord -= 0.5;
    const int2 ic(#floor(coord));
    const int2 ic0(#min(ic, tileExtent - 1));
    const int2 ic1(#min(ic + 1, tileExtent - 1));
    coord -= ic;
    return applyGamma(
             tex.gamma,
             math::lerp(math::lerp(#unpack_float4(tileBuffer[ic0.x + tileExtent.x * ic0.y]),           //
                                   #unpack_float4(tileBuffer[ic1.x + tileExtent.x * ic0.y]), coord.x), //
                        math::lerp(#unpack_float4(tileBuffer[ic0.x + tileExtent.x * ic1.y]),           //
                                   #unpack_float4(tileBuffer[ic1.x + tileExtent.x * ic1.y]), coord.x), coord.y),
           );
  } else {
    const auto i(getTileIndex(tex, int2(0)));
    return float4(0) if (i < 0);
    const auto tileExtent(tex.tile_extents[i]);
    const auto tileBuffer(tex.tile_buffers[i]);
    return float4(0) if (!tileBuffer);
    const auto iCropU(int2(crop_u * tileExtent));
    const auto iCropV(int2(crop_v * tileExtent));
    const auto iCorner0(int2(iCropU[0], iCropV[0]));
    const auto iCorner1(int2(iCropU[1], iCropV[1]));
    const auto subextent(iCorner1 - iCorner0);
    coord *= subextent;
    coord -= 0.5;
    const int2 wrap(int(wrap_u), int(wrap_v));
    const int2 ic(#floor(coord));
    const auto ic0(iCorner0 + applyWrap(wrap, subextent, ic));
    const auto ic1(iCorner0 + applyWrap(wrap, subextent, ic + 1));
    coord -= ic;
    return applyGamma(
             tex.gamma,
             math::lerp(math::lerp(#unpack_float4(tileBuffer[ic0.x + tileExtent.x * ic0.y]),           //
                                   #unpack_float4(tileBuffer[ic1.x + tileExtent.x * ic0.y]), coord.x), //
                        math::lerp(#unpack_float4(tileBuffer[ic0.x + tileExtent.x * ic1.y]),           //
                                   #unpack_float4(tileBuffer[ic1.x + tileExtent.x * ic1.y]), coord.x), coord.y),
           );
  }
}

@(pure macro)
export float3 lookup_float3(
  const texture_2d tex,
  const float2 coord,
  const wrap_mode wrap_u = wrap_repeat,
  const wrap_mode wrap_v = wrap_repeat,
  const float2 crop_u = float2(0.0, 1.0),
  const float2 crop_v = float2(0.0, 1.0),
) = lookup_float4(tex, coord, wrap_u, wrap_v, crop_u, crop_v).xyz;

@(pure macro)
export float2 lookup_float2(
  const texture_2d tex,
  const float2 coord,
  const wrap_mode wrap_u = wrap_repeat,
  const wrap_mode wrap_v = wrap_repeat,
  const float2 crop_u = float2(0.0, 1.0),
  const float2 crop_v = float2(0.0, 1.0),
) = lookup_float4(tex, coord, wrap_u, wrap_v, crop_u, crop_v).xy;

@(pure macro)
export float lookup_float(
  const texture_2d tex,
  const float2 coord,
  const wrap_mode wrap_u = wrap_repeat,
  const wrap_mode wrap_v = wrap_repeat,
  const float2 crop_u = float2(0.0, 1.0),
  const float2 crop_v = float2(0.0, 1.0),
) = lookup_float4(tex, coord, wrap_u, wrap_v, crop_u, crop_v).x;

@(pure macro)
export color lookup_color(
  const texture_2d tex,
  const float2 coord,
  const wrap_mode wrap_u = wrap_repeat,
  const wrap_mode wrap_v = wrap_repeat,
  const float2 crop_u = float2(0.0, 1.0),
  const float2 crop_v = float2(0.0, 1.0),
) = color(lookup_float4(tex, coord, wrap_u, wrap_v, crop_u, crop_v).xyz);

@(foreign)
void smdlPtexEvaluate(&void tex, int gamma, int first, int num, &float result);

@(macro)
export float4 lookup_float4(const texture_ptex tex, const int channel = 0) {
  float4 result;
  smdlPtexEvaluate(tex.ptr, tex.gamma, channel, 4, &result[0]);
  return result;
}

@(macro)
export float3 lookup_float3(const texture_ptex tex, const int channel = 0) {
  float3 result;
  smdlPtexEvaluate(tex.ptr, tex.gamma, channel, 3, &result[0]);
  return result;
}

@(macro)
export float2 lookup_float2(const texture_ptex tex, const int channel = 0) {
  float2 result;
  smdlPtexEvaluate(tex.ptr, tex.gamma, channel, 2, &result[0]);
  return result;
}

@(macro)
export float lookup_float(const texture_ptex tex, const int channel = 0) {
  float result;
  smdlPtexEvaluate(tex.ptr, tex.gamma, channel, 1, &result);
  return result;
}

@(macro)
export color lookup_color(const texture_ptex tex, const int channel = 0) {
  float3 result;
  smdlPtexEvaluate(tex.ptr, tex.gamma, channel, 3, &result[0]);
  return color(result);
}
