// NOTE: This module is non-standard!
#smdl

const int64_t PCG32_MULTIPLIER = 6364136223846793005;

const int64_t PCG32_DEFAULT_INCREMENT = 1442695040888963407;

export struct pcg32 {
  pcg32(int64_t seed) = return_from {
    auto pcg(pcg32(state: seed));
    pcg.state = pcg.state + pcg.increment;
    pcg.state = pcg.state * PCG32_MULTIPLIER + pcg.increment;
    return pcg;
  };

  pcg32(int64_t seed, int64_t stream) = return_from {
    auto pcg(pcg32(state: seed, increment: (stream << 1) | 1));
    pcg.state = pcg.state + pcg.increment;
    pcg.state = pcg.state * PCG32_MULTIPLIER + pcg.increment;
    return pcg;
  };

  int64_t state = 0;

  int64_t increment = PCG32_DEFAULT_INCREMENT;
};

@(pure)
export int32_t generate_int(inline const &pcg32 this) {
  state = state * PCG32_MULTIPLIER + increment;
  return #rotr(int32_t(((state >>> 18) ^ state) >>> 27), int32_t(31 & (state >>> 59)));
}

@(pure)
export int32_t generate_int(const &pcg32 this, const int32_t bound) {
  if (bound > 1) {
    const auto xmin((-bound) % bound);
    while (true) {
      const auto x(generate_int(this));
      return x % bound if (x >= xmin);
    }
  }
  return 0;
}

@(pure)
export float generate_float(const &pcg32 this) {
  return #min(float(#unsigned_to_fp(generate_int(this), double) / 4294967296.0d), 1.0 - $FLOAT_EPS / 2);
}

@(pure)
export float2 generate_float2(const &pcg32 this) = float2(generate_float(this), generate_float(this));

@(pure)
export float3 generate_float3(const &pcg32 this) = float3(generate_float(this), generate_float(this), generate_float(this));

@(pure)
export float4 generate_float4(const &pcg32 this) = float4(generate_float(this), generate_float(this), generate_float(this), generate_float(this));

@(pure)
export void discard(inline const &pcg32 this, int64_t n) {
  // Fast power by squaring.
  int64_t aTotal(1);
  int64_t bTotal(0);
  int64_t a(PCG32_MULTIPLIER);
  int64_t b(increment);
  while (n != 0) {
    if ((n & 1) != 0) {
      aTotal = aTotal * a;
      bTotal = bTotal * a + b;
    }
    b *= a + 1;
    a *= a;
    n >>>= 1;
  }
  state = state * aTotal + bTotal;
}
