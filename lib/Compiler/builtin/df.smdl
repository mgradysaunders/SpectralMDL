// vim:foldmethod=marker:foldlevel=0:fmr=--{,--}
#smdl

using ::math import *;

/// An arbitrary epsilon for stabilizing scattering calculations.
const float EPSILON = 1e-6;

/// An arbitrary chance for sampling diffusely in BSDFs with multiple-scattering.
const float MULTISCATTER_DIFFUSE_CHANCE = 0.2;

export enum scatter_mode {
  scatter_none = 0x0,             ///< None
  scatter_reflect = 0x1,          ///< Reflect (same hemisphere)
  scatter_transmit = 0x2,         ///< Transmit (opposite hemisphere) 
  scatter_reflect_transmit = 0x3, ///< Reflect or transmit 
};

@(pure macro) float scatter_reflect_chance(const scatter_mode mode) {
  const auto refl_weight(#select((int(mode) & 1) != 0, 1.0, 0.0));
  const auto tran_weight(#select((int(mode) & 2) != 0, 1.0, 0.0));
  return refl_weight / (refl_weight + tran_weight);
}

/// Declare libm `erf`
@(pure foreign) double erf(double x);

/// Declare libm `erfc`
@(pure foreign) double erfc(double x);

//--{ monte_carlo
export namespace monte_carlo {

/// Next canonical random vector in quasi-random 2-dimensional low discrepancy sequence.
export @(pure macro) float2 next_low_discrepancy(const &float2 xi) = (*xi = frac(*xi + float2(0.75487766, 0.56984029)));

/// Next canonical random vector in quasi-random 3-dimensional low discrepancy sequence.
export @(pure macro) float3 next_low_discrepancy(const &float3 xi) = (*xi = frac(*xi + float3(0.81917251, 0.67104360, 0.54970047)));

/// Next canonical random vector in quasi-random 4-dimensional low discrepancy sequence.
export @(pure macro) float4 next_low_discrepancy(const &float4 xi) = (*xi = frac(*xi + float4(0.85667488, 0.73389185, 0.62870672, 0.53859725)));

/// Bool sample with `chance` probability of returning `true`.
export @(pure) bool bool_sample(const &float xi, const float chance) {
  if (*xi < chance) {
    *xi = (*xi / chance);
    return true;
  } else {
    *xi = (*xi - chance) / (1 - chance);
    return false;
  }
}

/// Uniform wavelength index sample.
export @(pure) int uniform_wavelength_index_sample(const &float xi) {
  const int i(#min(int(*xi *= $WAVELENGTH_BASE_MAX), $WAVELENGTH_BASE_MAX - 1));
  *xi -= i;
  return i;
}

/// Uniform disk sample.
export @(pure noinline) float2 uniform_disk_sample(float2 xi) {
  xi = 2 * xi - 1;
  xi = #select(xi == 0, EPSILON, xi);
  const bool cond((absxi := #abs(xi), absxi.x > absxi.y));
  const float rad(#select(cond, xi.x, xi.y));
  const float phi(#select(cond, ($PI / 4) * xi.y / xi.x, ($PI / 2) - ($PI / 4) * xi.x / xi.y));
  return rad * float2(#cos(phi), #sin(phi));
}

/// Cosine-weighted hemisphere sample.
export @(pure noinline) float3 cosine_hemisphere_sample(float2 xi) {
  return float3((p := uniform_disk_sample(xi)), #sqrt(#max(1 - #sum(p * p), 0)));
}

/// Uniform hemisphere sample.
export @(pure noinline) float3 uniform_hemisphere_sample(float2 xi) {
  const float cos_theta = saturate(xi.x);
  const float sin_theta = #sqrt(1 - cos_theta * cos_theta);
  return float3(
    sin_theta * #cos(phi := $TWO_PI * xi.y),
    sin_theta * #sin(phi),
    cos_theta,
  );
}

/// Uniform sphere sample.
export @(pure noinline) float3 uniform_sphere_sample(float2 xi) {
  const float cos_theta = 2 * saturate(xi.x) - 1;
  const float sin_theta = #sqrt(1 - cos_theta * cos_theta);
  return float3(
    sin_theta * #cos(phi := $TWO_PI * xi.y),
    sin_theta * #sin(phi),
    cos_theta,
  );
}

/// Erf inverse.
export @(pure noinline) double erf_inverse(double y) {
  double w = -#log(#max(1e-6d, (1 - y) * (1 + y)));
  double x = 0;
  if (w < 5) {
    w = w - 2.5d;
    x = w * 2.81022636e-08d + 3.43273939e-7d;
    x = w * x - 3.52338770e-6d;
    x = w * x - 4.39150654e-6d;
    x = w * x + 2.18580870e-4d;
    x = w * x - 1.25372503e-3d;
    x = w * x - 4.17768164e-3d;
    x = w * x + 2.46640727e-1d;
    x = w * x + 1.50140941d;
  } else {
    w = #sqrt(w) - 3;
    x = x * -2.00214257e-4d + 1.00950558e-4d;
    x = w * x + 1.34934322e-3d;
    x = w * x - 3.67342844e-3d;
    x = w * x + 5.73950773e-3d;
    x = w * x - 7.62246130e-3d;
    x = w * x + 9.43887047e-3d;
    x = w * x + 1.00167406d;
    x = w * x + 2.83297682d;
  }
  x *= y;
  // Two rounds of Newton iteration.
  x -= (erf(x) - y) / (1.1283791671d * #exp(-x * x));
  x -= (erf(x) - y) / (1.1283791671d * #exp(-x * x));
  return x;
}

}
//--}

//--{ specular
export namespace specular {

/// Reflect direction `wi` across normal direction `wm`.
export @(pure macro) float3 reflect(const float3 wi, const float3 wm) = 2 * #sum(wi * wm) * wm - wi;

/// Reflect direction `wi` across normal direction `wm` with index of refraction `ior`.
export @(pure macro) float3 refract(const float3 wi, const float3 wm, const float ior) {
  const auto cos_thetai(#sum(wi * wm));
  const auto cos2_thetai(#min(cos_thetai * cos_thetai, 1));
  const auto cos2_thetat(#max(1 - ior * ior * (1 - cos2_thetai), 0));
  const auto cos_thetat(#sqrt(cos2_thetat) * -#sign(cos_thetai));
  return -ior * wi + (ior * cos_thetai + cos_thetat) * wm;
}

/// Calculate half vector that reflects direction `wo` to direction `wi`.
///
/// \note
/// - The result is not normalized.
/// - The result is guaranteed in the upper Z hemisphere.
///
export @(pure macro) float3 reflection_half_vector(const float3 wo, const float3 wi) = (vh := (wo + wi)) * #sign(vh.z);

/// Calculate half vector that refracts direction `wo` to direction `wi` through index-of-refraction `ior`.
///
/// \note
/// - The result is not normalized.
/// - The result is guaranteed in the upper Z hemisphere.
///
export @(pure macro) float3 refraction_half_vector(
  const float3 wo,
  const float3 wi,
  const float ior,
) = (vh := -(ior * wo + wi)) * #sign(vh.z);

export @(pure macro) auto refraction_half_vector_jacobian(
  const float3 wo,
  const float3 wi,
  const float ior,
) = #abs(#sum(wi * (vh := refraction_half_vector(wo, wi, ior)))) / ((vh2 := #sum(vh * vh)) * #sqrt(vh2));

export @(pure macro) auto schlick_F0(const auto ior) = #pow((ior - 1) / (ior + 1), 2);

export @(pure macro) auto schlick_fresnel(
  const auto cos_theta,
  const auto F0,
  const auto F90 = 1.0,
  const float exponent = 5,
) = F0 + (F90 - F0) * #pow(#max(1 - #abs(cos_theta), 0), exponent);

export @(pure) auto dielectric_fresnel(const float cos_thetai, const auto ior) {
  const auto cos2_thetat(1 - ior * ior * (1 - cos_thetai * cos_thetai));
  const auto cos_thetat(#sqrt(#max(cos2_thetat, 0)) * #sign(cos_thetai));
  const auto rs((ior * cos_thetai - cos_thetat) / (ior * cos_thetai + cos_thetat));
  const auto rp((cos_thetai - ior * cos_thetat) / (cos_thetai + ior * cos_thetat));
  return #min(0.5 * (rs * rs + rp * rp), 1.0);
}

}
//--}

/// Calculate the orthogonal right-handed tangent space from the 
/// given normal and tangent vectors.
@(pure noinline) float3x3 calculate_tangent_space(const float3 normal, const float3 tangent_u) {
  const auto tw(normalize(normal) * #sign(normal.z));
  const auto tu(normalize(tangent_u - dot(tangent_u, tw) * tw));
  const auto tv(normalize(cross(tw, tu)));
  return float3x3(tu, tv, tw);
}

struct scatter_evaluate_parameters {
  /// The reference outgoing direction in the natural tangent space.
  float3 wo0;

  /// The reference incoming direction in the natural tangent space.
  float3 wi0;

  /// The reference mode. 
  scatter_mode mode = (wo0.z < 0) == (wi0.z < 0) ? scatter_reflect : scatter_transmit;

  /// Hit backface?
  bool hit_backface = wo0.z < 0;

  /// Is thin walled?
  bool thin_walled = false;

  /// The relative upper-to-lower index of refraction.
  float ior = 1 / 1.4;

  /// The normal direction.
  float3 normal = float3(0, 0, 1);

  /// The tangent direction.
  float3 tangent_u = float3(1, 0, 0);

  /// The outgoing direction.
  float3 wo = wo0;

  /// The incoming direction.
  float3 wi = wi0;

  finalize {
    // If we hit the backface, flip everything so that `wo` 
    // is always in the upper hemisphere.
    if (hit_backface) {
      wo0 = -wo0;
      wi0 = -wi0;
      wo = -wo;
      wi = -wi;
      ior = 1 / ior;
    }
  }
};

struct scatter_evaluate_result {
  /// The Bidirectional Scattering Distribution Function (BSDF) evaluation.
  $(color | float) f = 0.0;

  /// The Probability Density Function (PDF) evaluations.
  /// - `pdf[0]` is the forward density of sampling `wi` given `wo`.
  /// - `pdf[1]` is the reverse density of sampling `wo` given `wi`.
  float2 pdf = float2(0.0);

  /// Is known to be black by construction? Faster than checking every 
  /// element of `f`!
  bool is_black = false;
};

/// Recalculate the effective tangent space.
///
/// \return
/// Returns `true` if the directions are still consistent with the scatter mode 
/// after applying the effective tangent space.
///
@(pure noinline) bool recalculate_tangent_space(inline const &scatter_evaluate_parameters params) {
  auto tbn(calculate_tangent_space(normal, tangent_u));
  wo = wo0 * tbn;
  wi = wi0 * tbn;
  return ((wo.z < 0) == (wo0.z < 0)) & ((wi.z < 0) == (wi0.z < 0));
}

@(pure) float3 half_direction(inline const &scatter_evaluate_parameters params) {
  return normalize(mode == scatter_reflect ? specular::reflection_half_vector(wo, wi) : specular::refraction_half_vector(wo, wi, ior));
}

struct scatter_sample_parameters {
  /// The primary outgoing direction in the natural geometric tangent space.
  float3 wo0;

  /// Hit backface?
  bool hit_backface = wo0.z < 0;

  /// Is thin walled?
  bool thin_walled = false;

  /// The active index of refraction.
  float ior = 1 / 1.4;

  /// The active normal direction.
  float3 normal = float3(0, 0, 1);

  /// The active tangent direction.
  float3 tangent_u = float3(1, 0, 0);

  /// The active outgoing direction (expanded in the active tangent space).
  float3 wo = wo0;

  /// The canonical random sample in [0,1]^4. 
  float4 xi;

  finalize {
    // If we hit the backface, flip everything so that `wo` 
    // is always in the upper hemisphere.
    if (hit_backface) {
      wo0 = -wo0;
      wo = -wo;
      ior = 1 / ior;
    }
  }
};

struct scatter_sample_result {
  /// The sampled incoming direction.
  float3 wi = float3(0.0);

  /// The sampled scatter mode.
  scatter_mode mode = scatter_none;

  /// If sampled from a directional delta distribution, the BSDF evaluation (which is otherwise unevaluable).
  ?color delta_f = null;
};

@(pure noinline) ?float3x3 recalculate_tangent_space(inline const &scatter_sample_parameters params) {
  auto tbn(calculate_tangent_space(normal, tangent_u));
  wo = wo0 * tbn;
  return tbn if ((wo.z < 0) == (wo0.z < 0));
}

@(pure) float3 half_direction(inline const &scatter_sample_parameters this, inline const &scatter_sample_result result) {
  return normalize(mode == scatter_reflect ? specular::reflection_half_vector(wo, wi) : specular::refraction_half_vector(wo, wi, ior));
}

export @(pure macro) auto $energy_loss_compensation(
  const string lut_name [[anno::unused()]],
  const float cos_thetao [[anno::unused()]],
  const float cos_thetai [[anno::unused()]],
  const float roughness [[anno::unused()]],
  const auto multiscatter_tint,
) {
  if $(multiscatter_tint <: void) {
    return 0.0;
  } else {
    const $albedo_lut lut(#albedo_lut(lut_name));
    float t((lut.num_roughness - 1) * #max(0, #min(roughness, 1)));
    const int j(#min(int(#floor(t)), lut.num_roughness - 2));
    t = t - j;
    const float Ewo = return_from {
      float s((lut.num_cos_theta - 1) * #max(0, #min(#abs(cos_thetao), 1)));
      const int i(#min(int(#floor(s)), lut.num_cos_theta - 2));
      const &float ptr0(&lut.directional_albedo[lut.num_roughness * (i + 0) + j]);
      const &float ptr1(&lut.directional_albedo[lut.num_roughness * (i + 1) + j]);
      return #min(1.0, lerp(lerp(ptr0[0], ptr0[1], t), lerp(ptr1[0], ptr1[1], t), s - i));
    };
    const float Ewi = return_from {
      float s((lut.num_cos_theta - 1) * #max(0, #min(#abs(cos_thetai), 1)));
      const int i(#min(int(#floor(s)), lut.num_cos_theta - 2));
      const &float ptr0(&lut.directional_albedo[lut.num_roughness * (i + 0) + j]);
      const &float ptr1(&lut.directional_albedo[lut.num_roughness * (i + 1) + j]);
      return #min(1.0, lerp(lerp(ptr0[0], ptr0[1], t), lerp(ptr1[0], ptr1[1], t), s - i));
    };
    const float Eav = #min(1, (1 - t) * lut.average_albedo[j] + t * lut.average_albedo[j + 1]);
    return #abs(cos_thetai) / $PI * (1 - Ewo) * (1 - Ewi) / (1 - Eav + 1e-6) * multiscatter_tint;
  }
}

//--{ default_bsdf
@(pure macro) auto scatter_evaluate(const &$default_bsdf this, const &scatter_evaluate_parameters params) {
  return scatter_evaluate_result(is_black: true);
}

@(pure macro) auto scatter_sample(const &$default_bsdf this, const &scatter_sample_parameters params) {
  return scatter_sample_result();
}
//--}

//--{ diffuse_reflection_bsdf
export struct diffuse_reflection_bsdf: bsdf {
  /// The tint.
  $(color | float) tint = 1.0;

  /// The roughness.
  float roughness = 0.0;

  /// The handle.
  string handle = "";

  /// The multiscatter tint.
  $(?(color | float)) multiscatter_tint = null;

  /// The mode implied by this BSDF.
  static const scatter_mode mode = scatter_reflect;
};

@(pure) auto scatter_evaluate(inline const &diffuse_reflection_bsdf this, inline const &scatter_evaluate_parameters params) {
  if (mode == scatter_reflect && recalculate_tangent_space(params)) {
    const auto cos_theta(#abs(auto(wi.z, wo.z)));
    const auto pdf(cos_theta / $PI);
    if (roughness == 0) {
      return scatter_evaluate_result(f: pdf[0] * tint, pdf: pdf);
    } else {
      // Oren-Nayar terms.
      const auto sigma2(2.0 * roughness * roughness);
      const auto A(1.00 - sigma2 / (2.0 * sigma2 + 0.66));
      const auto B(0.45 * sigma2 / (sigma2 + 0.09));
      const auto fss(pdf[0] * (A + #max(#sum(wo.xy * wi.xy), 0) / (#max_value(cos_theta) + EPSILON) * B));
      const auto fms($energy_loss_compensation("diffuse_reflection_bsdf", wo.z, wi.z, roughness, multiscatter_tint));
      return scatter_evaluate_result(f: tint * (fss + fms), pdf: pdf);
    }
  } else {
    return scatter_evaluate_result(is_black: true);
  }
}

@(pure) auto scatter_sample(inline const &diffuse_reflection_bsdf this, inline const &scatter_sample_parameters params) {
  if ((tbn := recalculate_tangent_space(params))) {
    return scatter_sample_result(wi: (*tbn) * monte_carlo::cosine_hemisphere_sample(xi.xy), mode: scatter_reflect);
  } else {
    return scatter_sample_result(); // Reject
  }
}
//--}

//--{ diffuse_transmission_bsdf
export struct diffuse_transmission_bsdf: bsdf {
  /// The tint.
  $(color | float) tint = 1.0;

  /// The handle.
  string handle = "";

  /// The mode implied by this BSDF.
  static const scatter_mode mode = scatter_transmit;
};

@(pure) auto scatter_evaluate(inline const &diffuse_transmission_bsdf this, inline const &scatter_evaluate_parameters params) {
  if (mode == scatter_transmit && recalculate_tangent_space(params)) {
    const auto cos_theta(#abs(auto(wi.z, wo.z)));
    const auto pdf(cos_theta / $PI);
    return scatter_evaluate_result(f: tint * pdf[0], pdf: pdf);
  } else {
    return scatter_evaluate_result(is_black: true);
  }
}

@(pure) auto scatter_sample(inline const &diffuse_transmission_bsdf this, inline const &scatter_sample_parameters params) {
  if ((tbn := recalculate_tangent_space(params))) {
    return scatter_sample_result(wi: (*tbn) * -monte_carlo::cosine_hemisphere_sample(xi.xy), mode: scatter_transmit);
  } else {
    return scatter_sample_result(); // Reject
  }
}
//--}

//--{ specular_bsdf
export struct specular_bsdf: bsdf {
  /// The tint.
  $(color | float) tint = 1.0;

  /// The scatter mode.
  scatter_mode mode = scatter_reflect;

  /// The handle.
  string handle = "";
};

@(pure macro) auto scatter_evaluate(const &specular_bsdf this, const &scatter_evaluate_parameters params) {
  return scatter_evaluate_result(is_black: true); // Delta function!
}

@(pure macro) auto scatter_sample(const &specular_bsdf this, inline const &scatter_sample_parameters params) {
  if ((tbn := recalculate_tangent_space(params))) {
    return xi.x < scatter_reflect_chance(this.mode)                                                                                       //
           ? scatter_sample_result(wi: (*tbn) * specular::reflect(wo, float3(0, 0, 1)), mode: scatter_reflect, delta_f: color(this.tint)) //
           : scatter_sample_result(wi: (*tbn) * specular::refract(wo, float3(0, 0, 1), ior), mode: scatter_transmit, delta_f: color(this.tint));
  } else {
    return scatter_sample_result(); // Reject
  }
}
//--}

//--{ sheen_bsdf
export struct sheen_bsdf: bsdf {
  /// The roughness.
  float roughness;

  /// The tint.
  $(color | float) tint = 1.0;

  /// The multiscatter tint.
  $(?(color | float)) multiscatter_tint = null;

  /// The multiscatter lobe. Unused, but I think this part of the later MDL spec?
  void multiscatter = null;

  /// The handle.
  string handle = "";

  finalize {
    roughness = saturate(roughness);
  }
};

@(pure) float sheen_lambda_L(const auto fit, const float mu) {
  return fit[0] / (1.0 + fit[1] * #pow(mu, fit[2])) + fit[3] * mu + fit[4];
}

@(pure) float sheen_lambda(const auto fit, const float mu) {
  return #exp(mu < 0.5 ? sheen_lambda_L(fit, mu) : 2 * sheen_lambda_L(fit, 0.5) - sheen_lambda_L(fit, #max(1 - mu, 0)));
}

@(pure) auto scatter_evaluate(inline const &sheen_bsdf this, inline const &scatter_evaluate_parameters params) {
  if (mode == scatter_reflect && recalculate_tangent_space(params)) {
    const auto cos_thetao(#abs(wo.z));
    const auto cos_thetai(#abs(wi.z));
    const auto pdf(float2(cos_thetai, cos_thetao) / $PI);
    const auto fss = let {
      const auto alpha(lerp(0.1, 1.0, roughness * roughness));
      const auto fit = lerp(
        auto(21.5473, 3.82987, 0.19823, -1.97760, -4.32054),
        auto(25.3245, 3.32435, 0.16801, -1.27393, -4.85967),
        #pow(1 - #pow(roughness, 2), 2),
      );
      const auto cos_thetah(normalize(wo + wi).z);
      const auto sin_thetah(#sqrt(1 - cos_thetah * cos_thetah));
      const auto D(1 / $TWO_PI * (2 + 1 / alpha) * #pow(sin_thetah, 1 / alpha));
      const auto G(1 / (1 + sheen_lambda(fit, cos_thetao) + sheen_lambda(fit, cos_thetai)));
    } in D * G / (4 * cos_thetao);
    const auto fms($energy_loss_compensation("sheen_bsdf", wo.z, wi.z, roughness, multiscatter_tint));
    return scatter_evaluate_result(f: tint * (fss + fms), pdf: pdf);
  } else {
    return scatter_evaluate_result(is_black: true);
  }
}

@(pure) auto scatter_sample(inline const &sheen_bsdf this, inline const &scatter_sample_parameters params) {
  if ((tbn := recalculate_tangent_space(params))) {
    return scatter_sample_result(wi: (*tbn) * monte_carlo::cosine_hemisphere_sample(xi.xy), mode: scatter_reflect);
  } else {
    return scatter_sample_result(); // Reject
  }
}
//--}

//--{ ward_geisler_moroder_bsdf 
export struct ward_geisler_moroder_bsdf: bsdf {
  /// The roughness in U.
  float roughness_u;

  /// The roughness in V.
  float roughness_v = roughness_u;

  /// The tint.
  $(color | float) tint = 1.0;

  /// The multiscatter tint, or `null` for no multiscatter.
  $(?(color | float)) multiscatter_tint = null;

  /// The tangent in U.
  float3 tangent_u = $state.texture_tangent_u[0];

  /// The handle.
  string handle = "";

  finalize {
    roughness_u = saturate(roughness_u);
    roughness_v = saturate(roughness_v);
  }
};

@(pure noinline) auto scatter_evaluate(const &ward_geisler_moroder_bsdf this, inline const &scatter_evaluate_parameters params) {
  preserve tangent_u;
  tangent_u = this.tangent_u;
  if (mode == scatter_reflect && recalculate_tangent_space(params)) {
    const auto cos_thetao(#abs(wo.z));
    const auto cos_thetai(#abs(wi.z));
    const auto roughness(this.roughness_u, this.roughness_v);
    const auto alpha(#max(0.001, roughness * roughness));
    const auto f(#sum((h := wo + wi) * h) / ($PI * alpha.x * alpha.y * #pow(h.z, 4)) * #exp(-#sum((g := h.xy / (h.z * alpha)) * g)));
    // Single-scattering.
    const auto fss_pdf(float2(f * (cos_thetao + cos_thetai) / 2));
    const auto fms_pdf(float2(cos_thetai, cos_thetao) / $PI);
    const auto fss(f * cos_thetai);
    const auto fms($energy_loss_compensation("ward_geisler_moroder_bsdf", wo.z, wi.z, #sqrt(#prod(roughness)), this.multiscatter_tint));
    if $(#typeof(this.multiscatter_tint) == void) {
      return scatter_evaluate_result(f: this.tint * fss, pdf: fss_pdf);
    } else {
      // Multiple-scattering.
      return scatter_evaluate_result(f: this.tint * (fss + fms), pdf: lerp(fss_pdf, fms_pdf, MULTISCATTER_DIFFUSE_CHANCE));
    }
  } else {
    return scatter_evaluate_result(is_black: true);
  }
}

@(pure noinline) auto scatter_sample(const &ward_geisler_moroder_bsdf this, inline const &scatter_sample_parameters params) {
  preserve tangent_u;
  tangent_u = this.tangent_u;
  if ((tbn := recalculate_tangent_space(params))) {
    // Sample diffuse (20% chance if multiscattering)
    if (#typeof(this.multiscatter_tint) != void && monte_carlo::bool_sample(&xi.w, MULTISCATTER_DIFFUSE_CHANCE)) {
      return scatter_sample_result(wi: (*tbn) * monte_carlo::cosine_hemisphere_sample(xi.xy), mode: scatter_reflect);
    }
    // Sample specular.
    const auto roughness(this.roughness_u, this.roughness_v);
    const auto alpha(#max(0.001, roughness * roughness));
    const auto phi(#atan2(alpha.y * #sin(t := $TWO_PI * xi.x), alpha.x * #cos(t)));
    const auto cos_phi(#cos(phi));
    const auto sin_phi(#sin(phi));
    const auto theta(#atan(#sqrt(-#log(1 - xi.y) / (#pow(cos_phi / alpha.x, 2) + #pow(sin_phi / alpha.y, 2)))));
    const auto wm(float3(#sin(theta) * float2(cos_phi, sin_phi), #cos(theta)));
    const auto wi(normalize(specular::reflect(wo, wm)));
    if (wi.z > 0) {
      return scatter_sample_result(wi: (*tbn) * wi, mode: scatter_reflect);
    }
  }
  return scatter_sample_result();
}
//--}

//--{ microfacet
export namespace microfacet {

/// The tag to identify microfacet distributions.
export tag distribution;

/// The GGX (Ground-Glass-X) or Trowbridge-Reitz distribution.
export struct distribution_ggx: default distribution {};

/// The Beckmann or Gaussian distribution.
export struct distribution_beckmann: distribution {};

/// The Smith Lambda function for the GGX distribution.
export @(pure macro) float smith_lambda(const distribution_ggx this [[anno::unused()]],
                                        const float m) {
  return 0.5 * (#sign(m) * #sqrt(1 + 1 / (m * m + EPSILON))) - 0.5;
}

/// The Smith Lambda function for the Beckmann distribution.
export @(pure macro) float smith_lambda(const distribution_beckmann this [[anno::unused()]],
                                        const float m) {
  return 0.5 * (#exp(-m * m) / m / #sqrt($PI) - float(erfc(m)));
}

/// The 2-dimensional Smith slope PDF for the GGX distribution.
export @(pure macro) float smith_slope_pdf(const distribution_ggx this [[anno::unused()]],
                                           const float2 m) {
  return (1 / $PI) / #pow(1 + #sum(m * m), 2);
}

/// The 2-dimensional Smith slope PDF for the Beckmann distribution.
export @(pure macro) float smith_slope_pdf(const distribution_beckmann this [[anno::unused()]],
                                           const float2 m) {
  return (1 / $PI) * #exp(-#sum(m * m));
}

/// The Smith visible slope sampling function for the GGX distribution.
export @(pure noinline) float2 smith_visible_slope_sample(
  const distribution_ggx this [[anno::unused()]],
  const float xi0,  ///< A canonical random number in `[0,1]`
  const float xi1,  ///< A canonical random number in `[0,1]`
  float cos_thetao, ///< The outgoing zenith angle cosine
) {
  return #sqrt(xi0 / (1 - xi0 + EPSILON)) * float2(#cos(phi := $TWO_PI * xi1), #sin(phi)) if (cos_thetao > 1 - EPSILON);
  cos_thetao = #max(cos_thetao, -0.9999);
  const auto mx = return_from {
    const auto sin_thetao(#sqrt(1 - cos_thetao * cos_thetao));
    const auto tan_thetao(sin_thetao / cos_thetao);
    const auto mu(xi0 * (1 + 1 / cos_thetao) - 1);
    const auto nu(1 / (1 - mu * mu));
    const auto D(#sqrt(#max(nu * (mu * mu - (1 - nu) * tan_thetao * tan_thetao), 0)));
    const auto mx0(-nu * tan_thetao - D);
    const auto mx1(-nu * tan_thetao + D);
    return #select((mu < 0) | (mx1 * sin_thetao > cos_thetao), mx0, mx1);
  };
  const auto my = return_from {
    const auto s(#select(xi1 > 0.5, +1.0, -1.0));
    const auto t(#min(s * (2 * xi1 - 1), 1));
    return #sqrt(1 + mx * mx) * s * ((t * (t * (t * 0.27385 - 0.73369) + 0.46341)) / (t * (t * (t * 0.093073 + 0.30942) - 1.0) + 0.597999));
  };
  return float2(mx, my);
}

/// The Smith visible slope sampling function for the Beckmann distribution.
export @(pure noinline) float2 smith_visible_slope_sample(
  const distribution_beckmann this [[anno::unused()]],
  float xi0,        ///< A canonical random number in `[0,1]`
  float xi1,        ///< A canonical random number in `[0,1]`
  float cos_thetao, ///< The outgoing zenith angle cosine
) {
  return #sqrt(-#log(1 - xi0 + EPSILON)) * float2(#cos((phi := $TWO_PI * xi1)), #sin(phi)) if (cos_thetao > 1 - EPSILON);
  xi0 = #max(xi0, EPSILON);
  xi1 = #max(xi1, EPSILON);
  // Implementation follows PBRT-v3
  const float SQRT_PI_INV = 1 / #sqrt($PI);
  const float thetao = #acos(cos_thetao);
  const float sin_thetao = #sqrt(#max(0, 1 - cos_thetao * cos_thetao));
  const float tan_thetao = sin_thetao / cos_thetao;
  const float cot_thetao = 1 / tan_thetao;
  float xmin = -1;
  float xmax = float(erf(cot_thetao));
  float x = xmax - (1 + xmax) * #pow(1 - xi0, 1 + thetao * (-0.876 + thetao * (0.4265 - 0.0594 * thetao)));
  float norm = 1 / (1 + xmax + SQRT_PI_INV * tan_thetao * #exp(-cot_thetao * cot_thetao));
  for (int i = 0; i < 10; ++i) {
    if (!(xmin <= x && x <= xmax))
      x = 0.5 * (xmin + xmax);
    const float a = monte_carlo::erf_inverse(x);
    const float f = norm * (1 + x + SQRT_PI_INV * tan_thetao * #exp(-a * a)) - xi0;
    break if (f ~== [1e-5] 0.0);
    if (f > 0)
      xmax = x;
    else
      xmin = x;
    x -= f / (norm * (1 - a * tan_thetao));
  }
  return float2(
    monte_carlo::erf_inverse(x),
    monte_carlo::erf_inverse(2 * xi1 - 1),
  );
}

// The Smith normal PDF.
export @(pure macro) float smith_normal_pdf(const distribution this [[anno::unused()]],
                                            const float2 alpha, const float3 wm) {
  return wm.z > 0.0 ? smith_slope_pdf(this, -wm.xy / (wm.z * alpha + EPSILON)) / (alpha.x * alpha.y * #pow(wm.z, 4) + EPSILON) : 0.0;
}

/// The Smith visible normal sampling function.
export @(pure noinline) float3 smith_visible_normal_sample(
  const distribution this,
  const float xi0,    ///< A canonical random number in `[0,1]`
  const float xi1,    ///< A canonical random number in `[0,1]`
  const float2 alpha, ///< The squared roughness 
  const float3 wo,    ///< The outgoing direction
) {
  const auto w11(normalize(float3(alpha * wo.xy, wo.z)));
  const auto sin_theta(length(w11.xy));
  const auto cos_phi(w11.x / sin_theta);
  const auto sin_phi(w11.y / sin_theta);
  const auto m11(smith_visible_slope_sample(this, xi0, xi1, w11.z));
  const auto m(float2(alpha.x * dot(float2(cos_phi, -sin_phi), m11), //
                      alpha.y * dot(float2(sin_phi, +cos_phi), m11)));
  return #all(isfinite(m)) ? normalize(float3(-m, 1)) : wo.z == 0 ? normalize(wo) : float3(0, 0, 1);
}

/// The Blinn distribution.
export struct distribution_blinn: distribution {};

/// The Blinn normal first-quadrant sampling function.
export @(pure macro) void blinn_normal_first_quadrant_sample(
  const float xi0,  ///< A canonical random number in `[0,1]`
  const float xi1,  ///< A canonical random number in `[0,1]`
  const float2 e,   ///< The exponent
  &float phi,       ///< The output azimuth angle
  &float cos_theta, ///< The output zenith angle cosine
) {
  if (e.x == e.y) {
    *phi = $HALF_PI * xi0;
    *cos_theta = #pow(xi1, 1 / (1 + e.x));
  } else {
    *phi = #atan(#sqrt((1 + e.x) / (1 + e.y)) * #tan($HALF_PI * xi0));
    *cos_theta = #pow(xi1, 1 / (1 + e.x * (cos_phi := #cos(*phi)) * cos_phi + e.y * (sin_phi := #sin(*phi)) * sin_phi));
  }
}

/// The Blinn normal sampling function.
export @(pure noinline) float3 blinn_normal_sample(
  const float xi0, ///< A canonical random number in `[0,1]`
  const float xi1, ///< A canonical random number in `[0,1]`
  const float2 e,  ///< The exponent
) {
  float phi = 0;
  float cos_theta = 0;
  if (xi0 < 0.25) {
    blinn_normal_first_quadrant_sample(4 * xi0, xi1, e, &phi, &cos_theta);
  } else if (xi0 < 0.5) {
    blinn_normal_first_quadrant_sample(4 * (0.5 - xi0), xi1, e, &phi, &cos_theta), phi = $PI - phi;
  } else if (xi0 < 0.75) {
    blinn_normal_first_quadrant_sample(4 * (xi0 - 0.5), xi1, e, &phi, &cos_theta), phi += $PI;
  } else {
    blinn_normal_first_quadrant_sample(4 * (1 - xi0), xi1, e, &phi, &cos_theta), phi = $TWO_PI - phi;
  }
  return float3(#sqrt(1 - cos_theta * cos_theta + EPSILON) * float2(#cos(phi), #sin(phi)), cos_theta);
}

/// The tag to identify microfacet shadowing functions.
export tag shadowing;

/// The Smith shadowing function. (This is the principled correct solution!)
export struct shadowing_smith: default shadowing {};

/// The V-cavities shadowing function. (This is the older simpler approximation!)
export struct shadowing_vcavities: shadowing {};

@(pure foreign) double lgamma(double x);

/// The beta function for Smith shadowing in transmission calculations.
export @(macro) double beta(const double x, const double y) = #exp(lgamma(x) + lgamma(y) - lgamma(x + y));

} // namespace microfacet

struct microfacet_bsdf: bsdf {
  /// The roughness in `[0,1]^2`.
  const float2 roughness;

  /// The geometric mean roughness.
  const float roughness0 = #sqrt(#prod(roughness));

  /// The roughness squared in `[EPSILON,1]^2`. 
  ///
  /// \note 
  /// This is the effective roughness parameter that is actually 
  /// used in microfacet equations. It is squared for perceptual linearity,
  /// meaning that adjusting the `roughness` parameter more closely tracks
  /// qualitative changes in the apparent roughness of the BSDF.
  ///
  const float2 alpha = clamp(roughness * roughness, EPSILON, 1.0);

  /// The tint.
  $(color | float) tint;

  /// The multiscatter tint, or `null` for no multiscatter.
  $(?(color | float)) multiscatter_tint = null;

  /// The tangent direction for orienting anistropic roughness.
  float3 tangent_u = $state.texture_tangent_u[0];

  /// The scatter mode.
  const scatter_mode mode = scatter_reflect;

  /// The microfacet distribution.
  const microfacet::distribution distribution = microfacet::distribution();

  /// The microfacet shadowing technique.
  const microfacet::shadowing shadowing = microfacet::shadowing();
};

@(pure noinline) auto scatter_evaluate(const &microfacet_bsdf this, inline const &scatter_evaluate_parameters params) {
  preserve tangent_u;
  tangent_u = this.tangent_u;
  return scatter_evaluate_result(is_black: true) if (!recalculate_tangent_space(params));
  const auto reflect_chance(scatter_reflect_chance(this.mode));
  const auto wm(normalize(mode == scatter_reflect ? wo + wi : specular::refraction_half_vector(wo, wi, ior)));
  const auto dot_wo_wm(#sum(wo * wm));
  const auto dot_wi_wm(#sum(wi * wm));
  if $(this.distribution <: microfacet::distribution_blinn) {
    const auto e(2 / (this.alpha * this.alpha + EPSILON));
    const auto D(#pow(wm.z, (e.x * wm.x * wm.x + e.y * wm.y * wm.y) / (1 - wm.z * wm.z + EPSILON)) / $TWO_PI);
    const auto norm1(#sqrt(#prod(1 + e)));
    const auto norm2(#sqrt(#prod(2 + e)));
    const auto G(#min(1, 2 * wm.z * #min(#abs(wo.z / dot_wo_wm), //
                                         #abs(wi.z / dot_wi_wm))));
    switch (mode & this.mode) {
    case scatter_reflect: {
      const auto fss_pdf(norm1 * D / (4 * float2(dot_wo_wm, dot_wi_wm) + EPSILON));
      const auto fss(norm2 * D * G / (4 * #abs(wo.z) + EPSILON));
      if $(this.multiscatter_tint <: void) {
        return scatter_evaluate_result(f: this.tint * (reflect_chance * fss), pdf: reflect_chance * fss_pdf);
      } else {
        const auto fms_pdf(float2(#abs(wi.z), #abs(wo.z)) / $PI);
        const auto fms($energy_loss_compensation("simple_glossy_bsdf", wo.z, wi.z, this.roughness0, this.multiscatter_tint));
        return scatter_evaluate_result(
          f: reflect_chance * (this.tint * (fss + fms)),
          pdf: reflect_chance * lerp(fss_pdf, fms_pdf, MULTISCATTER_DIFFUSE_CHANCE),
        );
      }
    }
    case scatter_transmit: {
      // TODO
      return scatter_evaluate_result(is_black: true) if (!((dot_wo_wm > 0) & (dot_wi_wm < 0)));
    }
    default: return scatter_evaluate_result(is_black: true);
    }
  } else {
    const auto D(microfacet::smith_normal_pdf(this.distribution, this.alpha, wm));
    const auto lambdao(microfacet::smith_lambda(this.distribution, #abs(wo.z) / length(this.alpha * wo.xy)));
    const auto lambdai(microfacet::smith_lambda(this.distribution, #abs(wi.z) / length(this.alpha * wi.xy)));
    const auto proj_areao((1 + lambdao) * #abs(wo.z));
    const auto proj_areai((1 + lambdai) * #abs(wi.z));
    const auto G = return_from {
      if $(this.shadowing <: microfacet::shadowing_smith) {
        return mode == scatter_reflect ? 1 / (1 + lambdao + lambdai) : float(microfacet::beta(1 + lambdao, 1 + lambdai));
      } else {
        // V-cavities
        return #min(1, 2 * wm.z * #min(#abs(wo.z / dot_wo_wm), //
                                       #abs(wi.z / dot_wi_wm)));
      }
    };
    switch (mode & this.mode) {
    case scatter_reflect: {
      const auto fss_pdf(D / (4 * float2(proj_areao, proj_areai) + EPSILON));
      const auto fss(D * G / (4 * #abs(wo.z) + EPSILON));
      if $(this.multiscatter_tint <: void) {
        return scatter_evaluate_result(f: this.tint * (reflect_chance * fss), pdf: reflect_chance * fss_pdf);
      } else {
        const auto fms_pdf(float2(#abs(wi.z), #abs(wo.z)) / $PI);
        const auto fms = return_from {
          if $(this.distribution <: microfacet::distribution_ggx) {
            return $energy_loss_compensation("microfacet_ggx_smith_bsdf", wo.z, wi.z, this.roughness0, this.multiscatter_tint);
          } else {
            return $energy_loss_compensation("microfacet_beckmann_smith_bsdf", wo.z, wi.z, this.roughness0, this.multiscatter_tint);
          }
        };
        return scatter_evaluate_result(
          f: reflect_chance * (this.tint * (fss + fms)),
          pdf: reflect_chance * lerp(fss_pdf, fms_pdf, MULTISCATTER_DIFFUSE_CHANCE),
        );
      }
    }
    case scatter_transmit: {
      return scatter_evaluate_result(is_black: true) if (!((dot_wo_wm > 0) & (dot_wi_wm < 0)));
      const auto jac(float2(specular::refraction_half_vector_jacobian(wo, wi, ior), //
                            specular::refraction_half_vector_jacobian(wi, wo, 1 / ior)));
      const auto fss_pdf(D * jac * float2(dot_wo_wm, -dot_wi_wm) / (float2(proj_areao, proj_areai) + EPSILON));
      const auto fss(D * G * jac[0] * dot_wo_wm / (#abs(wo.z) + EPSILON));
      return scatter_evaluate_result(f: this.tint * ((1 - reflect_chance) * fss), pdf: (1 - reflect_chance) * fss_pdf);
    }
    default: return scatter_evaluate_result(is_black: true);
    }
  }
  return scatter_evaluate_result(is_black: true);
}

@(pure noinline) auto scatter_sample(const &microfacet_bsdf this, inline const &scatter_sample_parameters params) {
  preserve tangent_u;
  tangent_u = this.tangent_u;
  auto tbn(recalculate_tangent_space(params));
  if (!tbn)
    return scatter_sample_result();
  // Decide whether to reflect or transmit. Note: This is not Fresnel-weighted. It is
  // either deterministic or 50/50.
  // - If `this.mode == scatter_reflect`, 100% chance to reflect.
  // - If `this.mode == scatter_transmit`, 100% chance to transmit.
  // - If `this.mode == scatter_reflect_transmit`, 50% chance to reflect and 50% chance to transmit.
  const auto mode(monte_carlo::bool_sample(&xi.z, scatter_reflect_chance(this.mode)) ? scatter_reflect : scatter_transmit);
  // If `multiscatter_tint` is present and we decided to reflect, sample a diffuse lobe occasionally.
  if (!(this.multiscatter_tint <: void) && mode == scatter_reflect && monte_carlo::bool_sample(&xi.w, MULTISCATTER_DIFFUSE_CHANCE)) {
    return scatter_sample_result(wi: (*tbn) * monte_carlo::cosine_hemisphere_sample(xi.xy), mode: scatter_reflect);
  }
  // Otherwise, sample a microsurface normal direction from the distribution, then either reflect or
  // refract through the normal depending on whether we decided to reflect or transmit. Note: The Blinn 
  // distribution is not a closed-form scale-invariant Smith distribution, so it has a separate normal 
  // sampling routine.
  const auto wm = return_from {
    if $(this.distribution <: microfacet::distribution_blinn) {
      return microfacet::blinn_normal_sample(xi.x, xi.y, 2 / (this.alpha * this.alpha + EPSILON));
    } else {
      return microfacet::smith_visible_normal_sample(this.distribution, xi.x, xi.y, this.alpha, wo);
    }
  };
  const auto wi = normalize(mode == scatter_reflect     //
                            ? specular::reflect(wo, wm) //
                            : specular::refract(wo, wm, ior));
  return scatter_sample_result(wi: (*tbn) * wi, mode: mode);
}

@(macro) auto initialize_microfacet_bsdf(
  const float roughness_u,
  const float roughness_v = roughness_u,
  const $(color | float) tint = 1.0,
  const $(?(color | float)) multiscatter_tint = null,
  const float3 tangent_u = $state.texture_tangent_u[0],
  const scatter_mode mode = scatter_reflect,
  const string handle = "" [[anno::unused()]],
  const microfacet::distribution distribution = microfacet::distribution(),
  const microfacet::shadowing shadowing = microfacet::shadowing(),
) {
  if ((roughness_u > 0) | (roughness_v > 0)) {
    return microfacet_bsdf(roughness: float2(roughness_u, roughness_v), tint: tint, multiscatter_tint: multiscatter_tint, tangent_u: normalize(tangent_u), mode: mode, //
                           distribution: distribution, shadowing: shadowing);
  } else {
    return specular_bsdf(tint: tint, mode: mode);
  }
}
//--}

export auto simple_glossy_bsdf(*) = initialize_microfacet_bsdf(distribution: microfacet::distribution_blinn(), shadowing: microfacet::shadowing_vcavities());

export auto microfacet_ggx_smith_bsdf(*) = initialize_microfacet_bsdf(distribution: microfacet::distribution_ggx(), shadowing: microfacet::shadowing_smith());

export auto microfacet_ggx_vcavities_bsdf(*) = initialize_microfacet_bsdf(distribution: microfacet::distribution_ggx(), shadowing: microfacet::shadowing_vcavities());

export auto microfacet_beckmann_smith_bsdf(*) = initialize_microfacet_bsdf(distribution: microfacet::distribution_beckmann(), shadowing: microfacet::shadowing_smith());

export auto microfacet_beckmann_vcavities_bsdf(*) = initialize_microfacet_bsdf(distribution: microfacet::distribution_beckmann(), shadowing: microfacet::shadowing_vcavities());

export bool bsdf_measurement_isvalid(const bsdf_measurement measurement) = bool(measurement.buffer);

export struct measured_bsdf: bsdf {
  bsdf_measurement measurement;

  float multiplier = 1.0;

  scatter_mode mode = scatter_reflect;

  string handle = "";
};

// TODO measured_bsdf

//--{ tint
/// A 1-value tint.
struct tint1: bsdf, edf, hair_bsdf {
  /// The tint multiplier.
  $(color | float) tint;

  /// The base `bsdf`, `edf`, or `hair_bsdf`.
  auto base;
};

/// A 2-value tint.
struct tint2: bsdf {
  /// The tint multiplier on reflection.
  $(color | float) reflection_tint;

  /// The tint multiplier on transmission.
  $(color | float) transmission_tint;

  /// The base `bsdf`.
  bsdf base;
};

/// Construct 1-value tint of the given `bsdf`.
export @(pure macro) auto tint(const auto tint, const bsdf base) = tint1(tint, base);

/// Construct 1-value tint of the given `edf`.
export @(pure macro) auto tint(const auto tint, const edf base) = tint1(tint, base);

/// Construct 1-value tint of the given `hair_bsdf`.
export @(pure macro) auto tint(const auto tint, const hair_bsdf base) = tint1(tint, base);

/// Construct 2-value tint of the given `bsdf`.
export @(pure macro) auto tint(const auto reflection_tint, const auto transmission_tint, const bsdf base) = tint2(reflection_tint, transmission_tint, base);

@(macro) auto scatter_evaluate(const &tint1 this, const &scatter_evaluate_parameters params) {
  auto result(scatter_evaluate(visit &this.base, params));
  if (!result.is_black)
    result.f *= this.tint;
  return result;
}

@(macro) auto scatter_evaluate(const &tint2 this, const &scatter_evaluate_parameters params) {
  auto result(scatter_evaluate(visit &this.base, params));
  if (!result.is_black) {
    if (params.mode == scatter_reflect) {
      result.f *= this.reflection_tint;
    } else {
      result.f *= this.transmission_tint;
    }
  }
  return result;
}

@(macro) auto scatter_sample(const &tint1 this, const &scatter_sample_parameters params) {
  auto result(scatter_sample(visit &this.base, params));
  if ((result.mode != scatter_none) & bool(result.delta_f))
    *result.delta_f *= this.tint;
  return result;
}

@(macro) auto scatter_sample(const &tint2 this, const &scatter_sample_parameters params) {
  auto result(scatter_sample(visit &this.base, params));
  if ((result.mode != scatter_none) & bool(result.delta_f)) {
    if (params.mode == scatter_reflect) {
      *result.delta_f *= this.reflection_tint;
    } else {
      *result.delta_f *= this.transmission_tint;
    }
  }
  return result;
}
//--}

//--{ weighted_layer, color_weighted_layer
export struct weighted_layer: bsdf {
  /// The weight. 
  $(color | float) weight;

  /// The layer BSDF.
  bsdf layer = bsdf();

  /// The base BSDF.
  bsdf base = bsdf();

  /// The normal to use for the layer.
  float3 normal = $state.normal;

  /// The chance of sampling the layer BSDF.
  ///
  /// \note
  /// If the weight is a `float`, then the chance is the same
  /// as the weight. However, if the weight is a `color`, we
  /// have to average it down to a single probability.
  ///
  float chance = average(weight);

  finalize {
    weight = saturate(weight);
    chance = saturate(chance);
  }
};

@(macro) auto scatter_evaluate(const &weighted_layer this, inline const &scatter_evaluate_parameters params) {
  auto result0(scatter_evaluate(visit &this.base, params));
  preserve normal;
  normal = this.normal;
  auto result1(scatter_evaluate(visit &this.layer, params));
  return scatter_evaluate_result(f: lerp(result0.f, result1.f, this.weight), pdf: lerp(result0.pdf, result1.pdf, this.chance), is_black: result0.is_black & result1.is_black);
}

@(macro) auto scatter_sample(const &weighted_layer this, inline const &scatter_sample_parameters params) {
  if (monte_carlo::bool_sample(&xi.w, this.chance)) {
    preserve normal;
    normal = this.normal;
    return scatter_sample(visit &this.layer, params);
  } else {
    return scatter_sample(visit &this.base, params);
  }
}

/// The `color_weighted_layer` is also implemented by the `weighted_layer`.
export typedef weighted_layer color_weighted_layer;
//--}

//--{ fresnel_layer, color_fresnel_layer
export struct fresnel_layer: bsdf {
  /// The index of refraction.
  $(color | float) ior;

  /// The weight.
  $(color | float) weight = 1.0;

  /// The layer BSDF.
  bsdf layer = bsdf();

  /// The base BSDF.
  bsdf base = bsdf();

  /// The normal to use for the layer.
  float3 normal = $state.normal;

  /// The precomputed average index of refraction.
  const float av_ior = average(ior);

  /// The precomputed average weight.
  const float av_weight = average(weight);
};

@(macro) auto scatter_evaluate(const &fresnel_layer this, inline const &scatter_evaluate_parameters params) {
  const auto cos_thetao(dot(wo, this.normal) * #sign(this.normal.z));
  const auto cos_thetai(dot(wi, this.normal) * #sign(this.normal.z));
  if ((cos_thetao < EPSILON)                                 //
      | ((mode == scatter_reflect) & (cos_thetai < EPSILON)) //
      | ((mode == scatter_transmit) & (cos_thetai > -EPSILON)))
    return scatter_evaluate_result(is_black: true);
  const auto result0(scatter_evaluate(visit &this.base, params));
  const auto result1 = return_from {
    preserve normal, ior;
    normal = this.normal, ior = 1 / this.av_ior; // Assume IOR of 1.4 => relative IOR of 1 / 1.4
    return scatter_evaluate(visit &this.layer, params);
  };
  if (result0.is_black & result1.is_black) {
    return scatter_evaluate_result(is_black: true);
  } else {
    return scatter_evaluate_result(
      f: lerp(result0.f, result1.f, this.weight * specular::dielectric_fresnel(dot(wo, half_direction(params)), 1 / this.ior)),
      pdf: lerp(result0.pdf, result1.pdf, this.av_weight * specular::schlick_fresnel(auto(cos_thetao, cos_thetai), specular::schlick_F0(this.av_ior))),
    );
  }
}

@(macro) auto scatter_sample(const &fresnel_layer this, inline const &scatter_sample_parameters params) {
  const auto cos_theta(dot(wo, this.normal) * #sign(this.normal.z));
  if (cos_theta < EPSILON)
    return scatter_sample_result();
  const auto chance(this.av_weight * specular::schlick_fresnel(cos_theta, specular::schlick_F0(this.av_ior)));
  if (monte_carlo::bool_sample(&xi.z, chance)) {
    preserve normal, ior;
    normal = this.normal, ior = 1 / this.av_ior; // Assume IOR of 1.4 => relative IOR of 1/1.4
    auto result(scatter_sample(visit &this.layer, params));
    *result.delta_f *= this.weight * specular::dielectric_fresnel(dot(wo, half_direction(params, &result)), 1 / this.ior) / chance if (result.delta_f);
    return result;
  } else {
    auto result(scatter_sample(visit &this.base, params));
    *result.delta_f *= (1 - this.weight * specular::dielectric_fresnel(dot(wo, half_direction(params, &result)), 1 / this.ior)) / (1 - chance) if (result.delta_f);
    return result;
  }
}

export typedef fresnel_layer color_fresnel_layer;
//--}

//--{ normalized_mix, clamped_mix, unbounded_mix
tag component;

export struct bsdf_component: component {
  float weight = 0.0;
  bsdf component = bsdf();
  float chance = weight; // NOTE: Non-standard!
};
export struct edf_component: component {
  float weight = 0.0;
  edf component = edf();
  float chance = weight; // NOTE: Non-standard!
};
export struct vdf_component: component {
  float weight = 0.0;
  vdf component = vdf();
  float chance = weight; // NOTE: Non-standard!
};

struct component_mix: bsdf, edf, vdf {
  component[] components;
};

export @(pure macro) auto normalized_mix(component[<N>] components) {
  float total_weight(0);
  float total_chance(0);
  for (int i = 0; i < N; i++) {
    auto component(&components[i]);
    component.weight = #max(component.weight, 0.0);
    component.chance = #max(component.chance, 0.0);
    total_weight += component.weight;
    total_chance += component.chance;
  }
  if (total_weight > 1.0)
    total_weight = 1.0 / total_weight;
  else
    total_weight = 1.0;
  total_chance = 1.0 / total_chance if (total_chance > 0.0);
  for (int i = 0; i < N; i++) {
    auto component(&components[i]);
    component.weight *= total_weight;
    component.chance *= total_chance;
  }
  return component_mix(components);
}

export @(pure macro) auto clamped_mix(component[<N>] components) {
  float total_weight(0);
  float total_chance(0);
  for (int i = 0; i < N; i++) {
    auto component(&components[i]);
    component.weight = #max(component.weight, 0.0);
    component.chance = #max(component.chance, 0.0);
    if (total_weight + component.weight < 1.0) {
      total_weight += component.weight;
      total_chance += component.chance;
    } else {
      // MDL specification:
      // Once a component weight would cause the sum to exceed 1.0, 
      // it is replaced with the result of subtracting the sum from 1.0.
      // All subsequent weights are then set to 0.0.
      component.weight = 1.0 - total_weight;
      for (int j = i + 1; j < N; j++) {
        components[j].weight = 0;
        components[j].chance = 0;
      }
      break;
    }
  }
  total_chance = 1.0 / total_chance if (total_chance > 0.0);
  for (int i = 0; i < N; i++) {
    components[i].chance *= total_chance;
  }
  return component_mix(components);
}

export @(pure macro) auto unbounded_mix(component[<N>] components) {
  float total_chance(0);
  for (int i = 0; i < N; i++) {
    auto component(&components[i]);
    component.weight = #max(component.weight, 0.0);
    component.chance = #max(component.chance, 0.0);
    total_chance += component.chance;
  }
  total_chance = 1.0 / total_chance if (total_chance > 0.0);
  for (int i = 0; i < N; i++) {
    components[i].chance *= total_chance;
  }
  return component_mix(components);
}

@(macro) auto scatter_evaluate(const &component_mix this, const &scatter_evaluate_parameters params) {
  auto result(scatter_evaluate_result(f: color(0), is_black: true));
  for (int i = 0; i < #num(this.components); i++) {
    visit component in this.components[i] { // In general this is a union!
      auto component_result(scatter_evaluate(&component.component, params));
      if (!component_result.is_black) {
        result.pdf += component.chance * component_result.pdf;
        result.f += component.weight * component_result.f;
        result.is_black = false;
      }
    }
  }
  return result;
}

@(macro) auto scatter_sample(const &component_mix this, const &scatter_sample_parameters params) {
  const auto xi(&params.xi.z);
  for (int i = 0; i < #num(this.components); i++) {
    visit component in this.components[i] { // In general this is a union!
      if (!(*xi < component.chance)) {
        *xi -= component.chance;
      } else {
        *xi /= component.chance;
        auto result(scatter_sample(&component.component, params));
        if ((result.mode != scatter_none) & bool(result.delta_f))
          *result.delta_f *= component.weight;
        return result;
      }
    }
  }
  return scatter_sample_result();
}
//--}

export @(macro) int $scatter_evaluate(
  const &$material_instance instance,
  const &float3 wo,     ///< The outgoing direction
  const &float3 wi,     ///< The incoming direction
  const &float pdf_fwd, ///< output: The PDF of sampling `wi` from `wo`
  const &float pdf_rev, ///< output: The PDF of sampling `wo` from `wi`
  const &float f,       ///< output: The scattering function
) {
  auto params = scatter_evaluate_parameters(wo0: normalize(*wo), wi0: normalize(*wi), normal: normalize(*instance.normal), thin_walled: instance.mat.thin_walled);
  auto result = instance.mat.backface <: #typeof(material_surface()) || !params.hit_backface //
                ? scatter_evaluate(visit &instance.mat.surface.scattering, &params)          //
                : scatter_evaluate(visit &instance.mat.backface.scattering, &params);
  visit result in result {
    if (result.is_black) {
      *pdf_fwd = 0.0;
      *pdf_rev = 0.0;
      for (int i = 0; i < $WAVELENGTH_BASE_MAX; i++)
        f[i] = 0.0;
    } else {
      *pdf_fwd = result.pdf[0];
      *pdf_rev = result.pdf[1];
      if (#typeof(result.f) == float) {
        for (int i = 0; i < $WAVELENGTH_BASE_MAX; i++)
          f[i] = result.f;
      } else {
        #memcpy(f, &result.f, #sizeof(float) * $WAVELENGTH_BASE_MAX);
      }
    }
    return !result.is_black;
  }
}

export @(macro) int $scatter_sample(
  const &$material_instance instance,
  const &float4 xi,     ///< The canonical random sample in `[0,1]^4`
  const &float3 wo,     ///< The outgoing direction
  const &float3 wi,     ///< output: The incoming direction
  const &float pdf_fwd, ///< output: The PDF of sampling `wi` from `wo`
  const &float pdf_rev, ///< output: The PDF of sampling `wo` from `wi`
  const &float f,       ///< output: The scattering function
  const &int is_delta,  ///< output: Is delta direction?
) {
  auto params = scatter_sample_parameters(xi: saturate(*xi), wo0: normalize(*wo), normal: normalize(*instance.normal), thin_walled: instance.mat.thin_walled);
  auto result = instance.mat.backface <: #typeof(material_surface()) || !params.hit_backface //
                ? scatter_sample(visit &instance.mat.surface.scattering, &params)            //
                : scatter_sample(visit &instance.mat.backface.scattering, &params);
  visit result in result {
    *wi = #select(params.hit_backface, -result.wi, +result.wi);
    if (result.mode == scatter_none || ((wo.z < 0.0) == (wi.z < 0.0)) != (result.mode == scatter_reflect)) {
      *pdf_fwd = 0.0;
      *pdf_rev = 0.0;
      for (int i = 0; i < $WAVELENGTH_BASE_MAX; i++)
        f[i] = 0.0;
      return false;
    }
    if ((*is_delta = bool(result.delta_f))) {
      *pdf_fwd = 1.0;
      *pdf_rev = 1.0;
      #memcpy(f, &*result.delta_f, #sizeof(float) * $WAVELENGTH_BASE_MAX);
      return true;
    } else {
      return $scatter_evaluate(instance, wo, wi, pdf_fwd, pdf_rev, f);
    }
  }
}

export @(macro) bool light_profile_isvalid(const light_profile profile) = bool(profile.ptr);

export @(macro) float light_profile_maximum(const light_profile profile) = profile.max_intensity;

export @(macro) float light_profile_power(const light_profile profile) = profile.power;

// TODO diffuse_edf

// TODO spot_edf

@(foreign pure) float smdl_light_profile_interpolate(const &void profile_ptr, const &float3 wo);

// TODO measured_edf
