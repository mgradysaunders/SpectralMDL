// vim:foldmethod=marker:foldlevel=0:fmr=--{,--}
#smdl

using ::math import *;

/// An arbitrary epsilon for stabilizing scattering calculations.
const float EPSILON = 1e-6;

/// An arbitrary chance for sampling diffusely in BSDFs with multiple-scattering.
const float MULTISCATTER_DIFFUSE_CHANCE = 0.2;

const int DF_REFLECTION = (1 << 0);

const int DF_TRANSMISSION = (1 << 1);

const int DF_DIFFUSE = (1 << 2);

const int DF_GLOSSY = (1 << 3);

const int DF_SPECULAR = (1 << 4);

@(macro)
float3x3 orthonormalBasis(float3 z) {
  z = normalize(z);
  auto x = z.z < -0.9999            //
           ? float3(0.0, -1.0, 0.0) //
           : float3(-z.x / (z.z + 1.0) + 1.0, -z.y / (z.z + 1.0), -1.0);
  x = normalize(x - dot(x, z) * z);
  auto y = normalize(cross(z, x));
  return float3x3(x, y, z);
}

export enum scatter_mode {
  scatter_none = 0x0,             ///< None
  scatter_reflect = 0x1,          ///< Reflect (same hemisphere)
  scatter_transmit = 0x2,         ///< Transmit (opposite hemisphere) 
  scatter_reflect_transmit = 0x3, ///< Reflect or transmit 
};

@(pure macro)
float scatterReflectChance(const scatter_mode mode) {
  const auto reflWeight(#select((int(mode) & 1) != 0, 1.0, 0.0));
  const auto tranWeight(#select((int(mode) & 2) != 0, 1.0, 0.0));
  return reflWeight / (reflWeight + tranWeight);
}

/// Declare libm `erf`
@(pure foreign)
double erf(double x);

/// Declare libm `erfc`
@(pure foreign)
double erfc(double x);

//--{ monte_carlo
export namespace monte_carlo {

/// Next canonical random vector in quasi-random 2-dimensional low discrepancy sequence.
@(pure macro)
export float2 nextLowDiscrepancy(const &float2 xi) = (*xi = frac(*xi + float2(0.75487766, 0.56984029)));

/// Next canonical random vector in quasi-random 3-dimensional low discrepancy sequence.
@(pure macro)
export float3 nextLowDiscrepancy(const &float3 xi) = (*xi = frac(*xi + float3(0.81917251, 0.67104360, 0.54970047)));

/// Next canonical random vector in quasi-random 4-dimensional low discrepancy sequence.
@(pure macro)
export float4 nextLowDiscrepancy(const &float4 xi) = (*xi = frac(*xi + float4(0.85667488, 0.73389185, 0.62870672, 0.53859725)));

/// Bool sample with `chance` probability of returning `true`.
@(pure macro)
export bool boolSample(const &float xi, const float chance) {
  if (*xi < chance) {
    *xi = (*xi / chance);
    return true;
  } else {
    *xi = (*xi - chance) / (1 - chance);
    return false;
  }
}

/// Uniform wavelength index sample.
@(pure macro)
export int uniformWavelengthIndexSample(const &float xi) {
  const int i(#min(int(*xi *= $WAVELENGTH_BASE_MAX), $WAVELENGTH_BASE_MAX - 1));
  *xi -= i;
  return i;
}

/// Uniform disk sample.
@(pure)
export float2 uniformDiskSample(float2 xi) {
  xi = 2 * xi - 1;
  xi = #select(xi == 0, EPSILON, xi);
  const bool cond((absxi := #abs(xi), absxi.x > absxi.y));
  const float rad(#select(cond, xi.x, xi.y));
  const float phi(#select(cond, ($PI / 4) * xi.y / xi.x, ($PI / 2) - ($PI / 4) * xi.x / xi.y));
  return rad * float2(#cos(phi), #sin(phi));
}

/// Cosine-weighted hemisphere sample.
@(pure)
export float3 cosineHemisphereSample(float2 xi) {
  return float3((p := uniformDiskSample(xi)), #sqrt(#max(1 - #sum(p * p), 0)));
}

/// Uniform hemisphere sample.
@(pure)
export float3 uniformHemisphereSample(float2 xi) {
  const float cosTheta = saturate(xi.x);
  const float sinTheta = #sqrt(1 - cosTheta * cosTheta);
  return float3(
           sinTheta * #cos(phi := $TWO_PI * xi.y),
           sinTheta * #sin(phi),
           cosTheta,
         );
}

/// Uniform sphere sample.
@(pure)
export float3 uniformSphereSample(float2 xi) {
  const float cosTheta = 2 * saturate(xi.x) - 1;
  const float sinTheta = #sqrt(1 - cosTheta * cosTheta);
  return float3(
           sinTheta * #cos(phi := $TWO_PI * xi.y),
           sinTheta * #sin(phi),
           cosTheta,
         );
}

/// Erf inverse.
@(pure)
export double erfInverse(double y) {
  double w = -#log(#max(1e-6d, (1 - y) * (1 + y)));
  double x = 0;
  if (w < 5) {
    w = w - 2.5d;
    x = w * 2.81022636e-08d + 3.43273939e-7d;
    x = w * x - 3.52338770e-6d;
    x = w * x - 4.39150654e-6d;
    x = w * x + 2.18580870e-4d;
    x = w * x - 1.25372503e-3d;
    x = w * x - 4.17768164e-3d;
    x = w * x + 2.46640727e-1d;
    x = w * x + 1.50140941d;
  } else {
    w = #sqrt(w) - 3;
    x = x * -2.00214257e-4d + 1.00950558e-4d;
    x = w * x + 1.34934322e-3d;
    x = w * x - 3.67342844e-3d;
    x = w * x + 5.73950773e-3d;
    x = w * x - 7.62246130e-3d;
    x = w * x + 9.43887047e-3d;
    x = w * x + 1.00167406d;
    x = w * x + 2.83297682d;
  }
  x *= y;
  // Two rounds of Newton iteration.
  x -= (erf(x) - y) / (1.1283791671d * #exp(-x * x));
  x -= (erf(x) - y) / (1.1283791671d * #exp(-x * x));
  return x;
}

}
//--}

//--{ specular
export namespace specular {

/// Reflect direction `wi` across normal direction `wm`.
@(pure)
export float3 reflect(const float3 wi, const float3 wm) = 2 * #sum(wi * wm) * wm - wi;

/// Reflect direction `wi` across normal direction `wm` with index of refraction `ior`.
@(pure)
export float3 refract(const float3 wi, const float3 wm, const float ior) {
  const auto cosThetai(#sum(wi * wm));
  const auto cos2Thetai(#min(cosThetai * cosThetai, 1));
  const auto cos2Thetat(#max(1 - ior * ior * (1 - cos2Thetai), 0));
  const auto cosThetat(#sqrt(cos2Thetat) * -#sign(cosThetai));
  return -ior * wi + (ior * cosThetai + cosThetat) * wm;
}

/// Calculate half vector that reflects direction `wo` to direction `wi`.
///
/// \note
/// - The result is not normalized.
/// - The result is guaranteed in the upper Z hemisphere.
///
@(pure)
export float3 reflectionHalfVector(const float3 wo, const float3 wi) = (vh := (wo + wi)) * #sign(vh.z);

/// Calculate half vector that refracts direction `wo` to direction `wi` through index-of-refraction `ior`.
///
/// \note
/// - The result is not normalized.
/// - The result is guaranteed in the upper Z hemisphere.
///
@(pure)
export float3 refractionHalfVector(
  const float3 wo,
  const float3 wi,
  const float ior,
) = (vh := -(ior * wo + wi)) * #sign(vh.z);

@(pure)
export auto refractionHalfVectorJacobian(
  const float3 wo,
  const float3 wi,
  const float ior,
) = #abs(#sum(wi * (vh := refractionHalfVector(wo, wi, ior)))) / ((vh2 := #sum(vh * vh)) * #sqrt(vh2));

@(pure macro)
export auto schlickF0(const auto ior) = #pow((ior - 1) / (ior + 1), 2);

@(pure macro)
export auto schlickFresnel(
  const auto cosTheta,
  const auto F0,
  const auto F90 = 1.0,
  const float exponent = 5,
) = F0 + (F90 - F0) * #pow(#max(1 - #abs(cosTheta), 0), exponent);

@(pure)
export auto dielectricFresnel(const float cosThetai, const auto ior) {
  const auto cosThetat = #sqrt(#max(1.0 - ior * ior * (1.0 - cosThetai * cosThetai), 0.0)) * #sign(cosThetai);
  const auto iorCosThetai = ior * cosThetai;
  const auto iorCosThetat = ior * cosThetat;
  const auto rs = (iorCosThetai - cosThetat) / (iorCosThetai + cosThetat);
  const auto rp = (cosThetai - iorCosThetat) / (cosThetai + iorCosThetat);
  return #min(0.5 * (rs * rs + rp * rp), 1.0);
}

@(pure)
export auto conductorFresnel(const float cosThetai, const auto ior) {
  const auto cosThetat = #sqrt(1.0 - ior * ior * (1.0 - cosThetai * cosThetai)) * #sign(cosThetai);
  const auto iorCosThetai = ior * cosThetai;
  const auto iorCosThetat = ior * cosThetat;
  const auto rs = (iorCosThetai - cosThetat) / (iorCosThetai + cosThetat);
  const auto rp = (cosThetai - iorCosThetat) / (cosThetai + iorCosThetat);
  return #min(0.5 * (#norm(rs) + #norm(rp)), 1.0);
}

}
//--}

/// Calculate the orthogonal right-handed tangent space from the 
/// given normal and tangent vectors.
@(pure noinline)
float3x3 calculateTangentSpace(const float3 normal, const float3 tangent_u) {
  const auto tw(normalize(normal) * #sign(normal.z));
  const auto tu(normalize(tangent_u - dot(tangent_u, tw) * tw));
  const auto tv(normalize(cross(tw, tu)));
  return float3x3(tu, tv, tw);
}

struct ScatterEvaluateParameters {
  /// Is transporting importance? i.e., tracing rays from lights to cameras?
  bool isImportance;

  /// The reference outgoing direction in the natural tangent space.
  float3 wo0;

  /// The reference incoming direction in the natural tangent space.
  float3 wi0;

  /// The reference mode. 
  scatter_mode mode = (wo0.z < 0) == (wi0.z < 0) ? scatter_reflect : scatter_transmit;

  /// Hit backface?
  bool hitBackface = wo0.z < 0;

  /// Is thin walled?
  bool thin_walled = false;

  /// The relative upper-to-lower index of refraction.
  float ior = 1 / 1.4;

  /// The normal direction.
  float3 normal = float3(0, 0, 1);

  /// The tangent direction.
  float3 tangent_u = float3(1, 0, 0);

  /// The outgoing direction.
  float3 wo = wo0;

  /// The incoming direction.
  float3 wi = wi0;

  float shadingNormalCorrection = 1;

  finalize {
    // If we hit the backface, flip everything so that `wo` 
    // is always in the upper hemisphere.
    if (hitBackface) {
      wo0 = -wo0;
      wi0 = -wi0;
      wo = -wo;
      wi = -wi;
      ior = 1.0 / ior;
    }
  }
};

struct ScatterEvaluateResult {
  /// The Bidirectional Scattering Distribution Function (BSDF) evaluation.
  $(color | float) f = 0.0;

  /// The Probability Density Function (PDF) evaluations.
  /// - `pdf[0]` is the forward density of sampling `wi` given `wo`.
  /// - `pdf[1]` is the reverse density of sampling `wo` given `wi`.
  float2 pdf = float2(0.0);

  /// Is known to be black by construction? Faster than checking every 
  /// element of `f`!
  bool isBlack = false;
};

/// Recalculate the effective tangent space.
///
/// \return
/// Returns `true` if the directions are still consistent with the scatter mode 
/// after applying the effective tangent space.
///
@(pure noinline)
bool recalculateTangentSpace(inline const &ScatterEvaluateParameters params) {
  auto tbn(calculateTangentSpace(normal, tangent_u));
  wo = normalize(wo0 * tbn);
  wi = normalize(wi0 * tbn);
  if (isImportance) {
    const auto numer = wo.z * wi0.z;
    const auto denom = wi.z * wo0.z;
    shadingNormalCorrection = (denom == 0 ? 1 : #abs(numer / denom));
  } else {
    shadingNormalCorrection = 1;
  }
  return ((wo.z < 0) == (wo0.z < 0)) & ((wi.z < 0) == (wi0.z < 0));
}

@(pure)
float3 halfDirection(inline const &ScatterEvaluateParameters params) {
  return normalize(mode == scatter_reflect                  //
                   ? specular::reflectionHalfVector(wo, wi) //
                   : specular::refractionHalfVector(wo, wi, ior));
}

struct ScatterSampleParameters {
  bool isImportance;

  /// The primary outgoing direction in the natural geometric tangent space.
  float3 wo0;

  /// Hit backface?
  bool hitBackface = wo0.z < 0;

  /// Is thin walled?
  bool thin_walled = false;

  /// The active index of refraction.
  float ior = 1 / 1.4;

  /// The active normal direction.
  float3 normal = float3(0, 0, 1);

  /// The active tangent direction.
  float3 tangent_u = float3(1, 0, 0);

  /// The active outgoing direction (expanded in the active tangent space).
  float3 wo = wo0;

  /// The canonical random sample in `[0,1]^4`. 
  float4 xi;

  finalize {
    // If we hit the backface, flip everything so that `wo` 
    // is always in the upper hemisphere.
    if (hitBackface) {
      wo0 = -wo0;
      wo = -wo;
      ior = 1 / ior;
    }
  }
};

struct ScatterSampleResult {
  /// The sampled incoming direction.
  float3 wi = float3(0.0);

  /// The sampled scatter mode.
  scatter_mode mode = scatter_none;

  /// If sampled from a directional delta distribution, the BSDF evaluation (which is otherwise unevaluable).
  ?color deltaValue = none;
};

@(pure noinline)
?float3x3 recalculateTangentSpace(inline const &ScatterSampleParameters params) {
  auto tbn(calculateTangentSpace(normal, tangent_u));
  wo = wo0 * tbn;
  return tbn if ((wo.z < 0) == (wo0.z < 0));
}

@(pure)
float3 halfDirection(inline const &ScatterSampleParameters this, inline const &ScatterSampleResult result) {
  return normalize(mode == scatter_reflect ? specular::reflectionHalfVector(wo, wi) : specular::refractionHalfVector(wo, wi, ior));
}

@(pure macro)
auto ScatterEvaluateResultWithMultiscatter(
  const auto this,
  const auto f,
  const float2 pdf,
  float cosThetao [[anno::unused()]],
  float cosThetai [[anno::unused()]],
  const float roughness [[anno::unused()]],
  const string lutName [[anno::unused()]],
) {
  if (#typeof(this.multiscatter_tint) == void || (#typeof(this.multiscatter_tint) == float && this.multiscatter_tint == 0.0)) {
    return ScatterEvaluateResult(f: this.tint * f, pdf: pdf);
  } else {
    cosThetao = #abs(cosThetao);
    cosThetai = #abs(cosThetai);
    const auto lut(#albedo_lut(lutName));
    float t((lut.num_roughness - 1) * saturate(roughness));
    const int j(#min(int(#floor(t)), lut.num_roughness - 2));
    t = t - j;
    const float Ewo = return_from {
      float s((lut.num_cos_theta - 1) * #min(cosThetao, 1));
      const int i(#min(int(#floor(s)), lut.num_cos_theta - 2));
      const &float ptr0(&lut.directional_albedo[lut.num_roughness * (i + 0) + j]);
      const &float ptr1(&lut.directional_albedo[lut.num_roughness * (i + 1) + j]);
      s = s - i;
      return #min(1.0, lerp(lerp(ptr0[0], ptr0[1], t), lerp(ptr1[0], ptr1[1], t), s));
    };
    const float Ewi = return_from {
      float s((lut.num_cos_theta - 1) * #min(cosThetai, 1));
      const int i(#min(int(#floor(s)), lut.num_cos_theta - 2));
      const &float ptr0(&lut.directional_albedo[lut.num_roughness * (i + 0) + j]);
      const &float ptr1(&lut.directional_albedo[lut.num_roughness * (i + 1) + j]);
      s = s - i;
      return #min(1.0, lerp(lerp(ptr0[0], ptr0[1], t), lerp(ptr1[0], ptr1[1], t), s));
    };
    const float Eav = #min(1.0, lerp(lut.average_albedo[j], lut.average_albedo[j + 1], t));
    const auto ms_f = cosThetai / $PI * (1 - Ewo) * (1 - Ewi) / (1 - Eav + 1e-6);
    const auto ms_pdf = auto(cosThetai, cosThetao) / $PI;
    return ScatterEvaluateResult(f: this.tint * (f + this.multiscatter_tint * ms_f), pdf: lerp(pdf, ms_pdf, MULTISCATTER_DIFFUSE_CHANCE));
  }
}

@(pure macro)
?ScatterSampleResult ScatterSampleResultWithMultiscatter(const auto this, const &float4 xi [[anno::unused()]], const float3x3 tbn [[anno::unused()]]) {
  if (#typeof(this.multiscatter_tint) == void || (#typeof(this.multiscatter_tint) == float && this.multiscatter_tint == 0.0)) {
    // Do nothing
  } else {
    if (monte_carlo::boolSample(&xi.w, MULTISCATTER_DIFFUSE_CHANCE)) {
      return ScatterSampleResult(wi: tbn * monte_carlo::cosineHemisphereSample(xi.xy), mode: scatter_reflect);
    }
  }
}

//--{ _default_bsdf
@(pure macro)
auto scatterEvaluate(const &_default_bsdf this [[anno::unused()]], const &ScatterEvaluateParameters params [[anno::unused()]]) {
  return ScatterEvaluateResult(isBlack: true);
}

@(pure macro)
auto scatterSample(const &_default_bsdf this [[anno::unused()]], const &ScatterSampleParameters params [[anno::unused()]]) {
  return ScatterSampleResult();
}
//--}

//--{ _default_vdf
@(macro)
auto scatterEvaluate(const &_default_vdf this [[anno::unused()]], const &ScatterEvaluateParameters params [[anno::unused()]]) {
  return ScatterEvaluateResult(isBlack: true);
}

@(macro)
auto scatterSample(const &_default_vdf this [[anno::unused()]], const &ScatterSampleParameters params [[anno::unused()]]) {
  return ScatterSampleResult();
}
//--}

//--{ diffuse_reflection_bsdf
export struct diffuse_reflection_bsdf: bsdf {
  /// The tint.
  ///
  /// > Scaling factor, defined as a color, multiplied by the 
  /// > result of the distribution function.
  ///
  const $(color | float) tint = 1.0;

  /// The roughness.
  ///
  /// > Oren-Nayar roughness coefficient, simulating view-dependent diffuse 
  /// > reflection. Range: `[0,1]`, with `0` specifying complete view 
  /// > independence.
  ///
  const float roughness = 0.0;

  /// The handle.
  ///
  /// > Name to provide access to this component for use in an MDL 
  /// > integration.
  ///
  /// \note
  /// This should be a `string` but we `void` it because we have no use for it.
  ///
  void handle = "";

  /// The multiscatter tint.
  const $(?(color | float)) multiscatter_tint = none;

  /// The flags.
  static const int _flags = DF_REFLECTION | DF_DIFFUSE;
};

@(pure)
auto scatterEvaluate(const &diffuse_reflection_bsdf this, inline const &ScatterEvaluateParameters params) {
  if (mode == scatter_reflect && recalculateTangentSpace(params)) {
    const auto cosTheta(#abs(auto(wi.z, wo.z)));
    const auto pdf(cosTheta / $PI);
    if (this.roughness == 0) {
      auto result(ScatterEvaluateResult(f: this.tint * pdf[0], pdf: pdf));
      result.f *= shadingNormalCorrection if (isImportance);
      return result;
    } else {
      // Oren-Nayar terms.
      const auto sigma2(2.0 * this.roughness * this.roughness);
      const auto A(1.00 - sigma2 / (2.0 * sigma2 + 0.66));
      const auto B(0.45 * sigma2 / (sigma2 + 0.09));
      const auto f(pdf[0] * (A + #max(#sum(wo.xy * wi.xy), 0) / (#max_value(cosTheta) + EPSILON) * B));
      auto result(ScatterEvaluateResultWithMultiscatter(this, f, pdf, wo.z, wi.z, this.roughness, "diffuse_reflection_bsdf"));
      result.f *= shadingNormalCorrection if (isImportance);
      return result;
    }
  } else {
    return ScatterEvaluateResult(isBlack: true);
  }
}

@(pure)
auto scatterSample(const &diffuse_reflection_bsdf this [[anno::unused()]], inline const &ScatterSampleParameters params) {
  if ((tbn := recalculateTangentSpace(params))) {
    return ScatterSampleResult(wi: (*tbn) * monte_carlo::cosineHemisphereSample(xi.xy), mode: scatter_reflect);
  } else {
    return ScatterSampleResult(); // Reject
  }
}
//--}

//--{ diffuse_transmission_bsdf
export struct diffuse_transmission_bsdf: bsdf {
  /// The tint.
  ///
  /// > Scaling factor, defined as a color, multiplied by the 
  /// > result of the distribution function.
  ///
  const $(color | float) tint = 1.0;

  /// The handle.
  ///
  /// > Name to provide access to this component for use in an MDL 
  /// > integration.
  ///
  /// \note
  /// This should be a `string` but we `void` it because we have no use for it.
  ///
  void handle = "";

  /// The flags.
  static const int _flags = DF_TRANSMISSION | DF_DIFFUSE;
};

@(pure)
auto scatterEvaluate(inline const &diffuse_transmission_bsdf this, inline const &ScatterEvaluateParameters params) {
  if (mode == scatter_transmit && recalculateTangentSpace(params)) {
    const auto cosTheta(#abs(auto(wi.z, wo.z)));
    const auto pdf(cosTheta / $PI);
    auto result(ScatterEvaluateResult(f: tint * pdf[0], pdf: pdf));
    result.f *= shadingNormalCorrection if (isImportance);
    return result;
  } else {
    return ScatterEvaluateResult(isBlack: true);
  }
}

@(pure)
auto scatterSample(inline const &diffuse_transmission_bsdf this, inline const &ScatterSampleParameters params) {
  if ((tbn := recalculateTangentSpace(params))) {
    return ScatterSampleResult(wi: (*tbn) * -monte_carlo::cosineHemisphereSample(xi.xy), mode: scatter_transmit);
  } else {
    return ScatterSampleResult(); // Reject
  }
}
//--}

//--{ specular_bsdf
export struct specular_bsdf: bsdf {
  /// The tint.
  ///
  /// > Scaling factor, defined as a color, multiplied by the 
  /// > result of the distribution function.
  ///
  const $(color | float) tint = 1.0;

  /// The scatter mode.
  ///
  /// > One of three values: `scatter_reflect`, `scatter_transmit`, 
  /// > or (for both) `scatter_reflect_transmit`.
  ///
  const scatter_mode mode = scatter_reflect;

  /// The handle.
  ///
  /// > Name to provide access to this component for use in an MDL 
  /// > integration.
  ///
  /// \note
  /// This should be a `string` but we `void` it because we have no use for it.
  ///
  void handle = "";

  /// The flags.
  const int _flags = int(mode) | DF_SPECULAR;
};

@(pure macro)
auto scatterEvaluate(const &specular_bsdf this [[anno::unused()]], const &ScatterEvaluateParameters params [[anno::unused()]]) {
  return ScatterEvaluateResult(isBlack: true); // Delta function!
}

@(pure macro)
auto scatterSample(const &specular_bsdf this, inline const &ScatterSampleParameters params) {
  if ((tbn := recalculateTangentSpace(params))) {
    if (xi.x < scatterReflectChance(this.mode)) {
      return ScatterSampleResult(wi: (*tbn) * specular::reflect(wo, float3(0, 0, 1)), mode: scatter_reflect, deltaValue: color(this.tint));
    } else {
      auto result = ScatterSampleResult(wi: (*tbn) * specular::refract(wo, float3(0, 0, 1), ior), mode: scatter_transmit, deltaValue: color(this.tint));
      *result.deltaValue *= ior * ior if (!isImportance);
      if (isImportance) {
        // TODO Account for shading normal correction
      }
      return result;
    }
  } else {
    return ScatterSampleResult(); // Reject
  }
}
//--}

//--{ sheen_bsdf
export struct sheen_bsdf: bsdf {
  /// The roughness.
  ///
  /// > Roughness coefficient. Range: `[0,inf)`, with `0` specifying pure 
  /// > specular reflection.
  ///
  float roughness;

  /// The tint.
  ///
  /// > Scaling factor, defined as a color, multiplied by the result of the 
  /// > distribution function.
  ///
  const $(color | float) tint = 1.0;

  /// The multiscatter tint.
  ///
  /// > Scaling factor, defined as a color, of the diffuse multiscattering 
  /// > compensation, `color(0.0)` does not add any, `color(1.0)` fully 
  /// > compensates the energy loss.
  ///
  const $(?(color | float)) multiscatter_tint = none;

  /// The multiscatter lobe.
  ///
  /// Currently unused, part of the later MDL spec?
  ///
  void multiscatter = none;

  /// The handle.
  ///
  /// > Name to provide access to this component for use in an MDL 
  /// > integration.
  ///
  /// \note
  /// This should be a `string` but we `void` it because we have no use for it.
  ///
  void handle = "";

  /// The flags.
  static const int _flags = DF_REFLECTION | DF_DIFFUSE;

  finalize {
    roughness = saturate(roughness);
  }
};

@(pure)
float sheen_lambda_L(const auto fit, const float mu) {
  return fit[0] / (1.0 + fit[1] * #pow(mu, fit[2])) + fit[3] * mu + fit[4];
}

@(pure)
float sheen_lambda(const auto fit, const float mu) {
  return #exp(mu < 0.5 ? sheen_lambda_L(fit, mu) : 2 * sheen_lambda_L(fit, 0.5) - sheen_lambda_L(fit, #max(1 - mu, 0)));
}

@(pure)
auto scatterEvaluate(const &sheen_bsdf this, inline const &ScatterEvaluateParameters params) {
  if (mode == scatter_reflect && recalculateTangentSpace(params)) {
    const auto cosThetao(#abs(wo.z));
    const auto cosThetai(#abs(wi.z));
    const auto pdf(float2(cosThetai, cosThetao) / $PI);
    const auto f = let {
      const auto alpha(lerp(0.1, 1.0, #pow(this.roughness, 2)));
      const auto fit = lerp(
        auto(21.5473, 3.82987, 0.19823, -1.97760, -4.32054),
        auto(25.3245, 3.32435, 0.16801, -1.27393, -4.85967),
        #pow(1 - #pow(this.roughness, 2), 2),
      );
      const auto cosThetah(normalize(wo + wi).z);
      const auto sinThetah(#sqrt(1 - cosThetah * cosThetah));
      const auto D(1 / $TWO_PI * (2 + 1 / alpha) * #pow(sinThetah, 1 / alpha));
      const auto G(1 / (1 + sheen_lambda(fit, cosThetao) + sheen_lambda(fit, cosThetai)));
    } in D * G / (4 * cosThetao);
    auto result(ScatterEvaluateResultWithMultiscatter(this, f, pdf, cosThetao, cosThetai, this.roughness, "sheen_bsdf"));
    result.f *= shadingNormalCorrection if (isImportance);
    return result;
  } else {
    return ScatterEvaluateResult(isBlack: true);
  }
}

@(pure)
auto scatterSample(const &sheen_bsdf this [[anno::unused()]], inline const &ScatterSampleParameters params) {
  if ((tbn := recalculateTangentSpace(params))) {
    return ScatterSampleResult(wi: (*tbn) * monte_carlo::cosineHemisphereSample(xi.xy), mode: scatter_reflect);
  } else {
    return ScatterSampleResult(); // Reject
  }
}
//--}

//--{ ward_geisler_moroder_bsdf 
export struct ward_geisler_moroder_bsdf: bsdf {
  /// The roughness in U.
  ///
  /// > Roughness coefficient in the U direction. Range: `[0,inf)`, with `0`
  /// > specifying pure specular reflection.
  ///
  float roughness_u;

  /// The roughness in V.
  ///
  /// > Roughness coefficient in the V direction. Range: `[0,inf)`, with `0`
  /// > specifying pure specular reflection.
  ///
  float roughness_v = roughness_u;

  /// The tint.
  ///
  /// > Scaling factor, defined as a color, multiplied by the result of the 
  /// > distribution function.
  ///
  $(color | float) tint = 1.0;

  /// The multiscatter tint.
  ///
  /// > Scaling factor, defined as a color, of the diffuse multiscattering 
  /// > compensation, `color(0.0)` does not add any, `color(1.0)` fully 
  /// > compensates the energy loss.
  ///
  $(?(color | float)) multiscatter_tint = none;

  /// The tangent in U.
  float3 tangent_u = $state.texture_tangent_u[0];

  /// The handle.
  ///
  /// > Name to provide access to this component for use in an MDL 
  /// > integration.
  ///
  /// \note
  /// This should be a `string` but we `void` it because we have no use for it.
  ///
  void handle = "";

  /// The flags.
  static const int _flags = DF_REFLECTION | DF_GLOSSY;

  finalize {
    // We limit to `[0,1]`!
    roughness_u = saturate(roughness_u);
    roughness_v = saturate(roughness_v);
  }
};

@(pure noinline)
auto scatterEvaluate(const &ward_geisler_moroder_bsdf this, inline const &ScatterEvaluateParameters params) {
  preserve tangent_u;
  tangent_u = this.tangent_u;
  if (mode == scatter_reflect && recalculateTangentSpace(params)) {
    const auto cosThetao(#abs(wo.z));
    const auto cosThetai(#abs(wi.z));
    const auto roughness(this.roughness_u, this.roughness_v);
    const auto roughness0(#sqrt(#prod(roughness)));
    const auto alpha(#max(0.001, roughness * roughness));
    const auto f0(#sum((h := wo + wi) * h) / ($PI * alpha.x * alpha.y * #pow(h.z, 4)) * #exp(-#sum((g := h.xy / (h.z * alpha)) * g)));
    const auto f(f0 * cosThetai);
    const auto pdf(float2(f0 * (cosThetao + cosThetai) / 2));
    auto result(ScatterEvaluateResultWithMultiscatter(this, f, pdf, cosThetao, cosThetai, roughness0, "ward_geisler_moroder_bsdf"));
    result.f *= shadingNormalCorrection if (isImportance);
    return result;
  } else {
    return ScatterEvaluateResult(isBlack: true);
  }
}

@(pure noinline)
auto scatterSample(const &ward_geisler_moroder_bsdf this, inline const &ScatterSampleParameters params) {
  preserve tangent_u;
  tangent_u = this.tangent_u;
  if ((tbn := recalculateTangentSpace(params))) {
    // Sample multiscatter.
    if (result := ScatterSampleResultWithMultiscatter(this, xi, *tbn)) {
      return *result;
    } else {
      // Sample specular.
      const auto roughness(this.roughness_u, this.roughness_v);
      const auto alpha(#max(0.001, roughness * roughness));
      const auto phi(#atan2(alpha.y * #sin(t := $TWO_PI * xi.x), alpha.x * #cos(t)));
      const auto cosPhi(#cos(phi));
      const auto sinPhi(#sin(phi));
      const auto theta(#atan(#sqrt(-#log(1 - xi.y) / (#pow(cosPhi / alpha.x, 2) + #pow(sinPhi / alpha.y, 2)))));
      const auto wm(float3(#sin(theta) * float2(cosPhi, sinPhi), #cos(theta)));
      const auto wi(normalize(specular::reflect(wo, wm)));
      if (wi.z > 0) {
        return ScatterSampleResult(wi: (*tbn) * wi, mode: scatter_reflect);
      }
    }
  }
  return ScatterSampleResult();
}
//--}

//--{ microfacet
export namespace microfacet {

/// The tag to identify microfacet distributions.
export tag distribution;

/// The GGX (Ground-Glass-X) or Trowbridge-Reitz distribution.
export struct distribution_ggx: default distribution {};

/// The Beckmann or Gaussian distribution.
export struct distribution_beckmann: distribution {};

/// The Smith Lambda function for the GGX distribution.
@(pure macro)
export float smithLambda(const distribution_ggx this [[anno::unused()]], const float m) {
  return 0.5 * (#sign(m) * #sqrt(1 + 1 / (m * m + EPSILON))) - 0.5;
}

/// The Smith Lambda function for the Beckmann distribution.
@(pure macro)
export float smithLambda(const distribution_beckmann this [[anno::unused()]], const float m) {
  return 0.5 * (#exp(-m * m) / m / #sqrt($PI) - float(erfc(m)));
}

/// The 2-dimensional Smith slope PDF for the GGX distribution.
@(pure macro)
export float smithSlopePDF(const distribution_ggx this [[anno::unused()]], const float2 m) {
  return (1 / $PI) / #pow(1 + #sum(m * m), 2);
}

/// The 2-dimensional Smith slope PDF for the Beckmann distribution.
@(pure macro)
export float smithSlopePDF(const distribution_beckmann this [[anno::unused()]], const float2 m) {
  return (1 / $PI) * #exp(-#sum(m * m));
}

/// The Smith visible slope sampling function for the GGX distribution.
@(pure)
export float2 smithVisibleSlopeSample(
  const distribution_ggx this [[anno::unused()]],
  const float xi0, ///< A canonical random number in `[0,1]`
  const float xi1, ///< A canonical random number in `[0,1]`
  float cosThetao, ///< The outgoing zenith angle cosine
) {
  return #sqrt(xi0 / (1 - xi0 + EPSILON)) * float2(#cos(phi := $TWO_PI * xi1), #sin(phi)) if (cosThetao > 1 - EPSILON);
  cosThetao = #max(cosThetao, -0.9999);
  const auto mx = return_from {
    const auto sinThetao(#sqrt(1 - cosThetao * cosThetao));
    const auto tanThetao(sinThetao / cosThetao);
    const auto mu(xi0 * (1 + 1 / cosThetao) - 1);
    const auto nu(1 / (1 - mu * mu));
    const auto D(#sqrt(#max(nu * (mu * mu - (1 - nu) * tanThetao * tanThetao), 0)));
    const auto mx0(-nu * tanThetao - D);
    const auto mx1(-nu * tanThetao + D);
    return #select((mu < 0) | (mx1 * sinThetao > cosThetao), mx0, mx1);
  };
  const auto my = return_from {
    const auto s(#select(xi1 > 0.5, +1.0, -1.0));
    const auto t(#min(s * (2 * xi1 - 1), 1));
    return #sqrt(1 + mx * mx) * s * ((t * (t * (t * 0.27385 - 0.73369) + 0.46341)) / (t * (t * (t * 0.093073 + 0.30942) - 1.0) + 0.597999));
  };
  return float2(mx, my);
}

/// The Smith visible slope sampling function for the Beckmann distribution.
@(pure)
export float2 smithVisibleSlopeSample(
  const distribution_beckmann this [[anno::unused()]],
  float xi0,       ///< A canonical random number in `[0,1]`
  float xi1,       ///< A canonical random number in `[0,1]`
  float cosThetao, ///< The outgoing zenith angle cosine
) {
  return #sqrt(-#log(1 - xi0 + EPSILON)) * float2(#cos((phi := $TWO_PI * xi1)), #sin(phi)) if (cosThetao > 1 - EPSILON);
  xi0 = #max(xi0, EPSILON);
  xi1 = #max(xi1, EPSILON);
  // Implementation follows PBRT-v3
  const float SQRT_PI_INV = 1 / #sqrt($PI);
  const float thetao = #acos(cosThetao);
  const float sinThetao = #sqrt(#max(0, 1 - cosThetao * cosThetao));
  const float tanThetao = sinThetao / cosThetao;
  const float cotThetao = 1 / tanThetao;
  float xmin = -1;
  float xmax = float(erf(cotThetao));
  float x = xmax - (1 + xmax) * #pow(1 - xi0, 1 + thetao * (-0.876 + thetao * (0.4265 - 0.0594 * thetao)));
  float norm = 1 / (1 + xmax + SQRT_PI_INV * tanThetao * #exp(-cotThetao * cotThetao));
  for (int i = 0; i < 10; ++i) {
    if (!(xmin <= x && x <= xmax))
      x = 0.5 * (xmin + xmax);
    const float a = monte_carlo::erfInverse(x);
    const float f = norm * (1 + x + SQRT_PI_INV * tanThetao * #exp(-a * a)) - xi0;
    break if (f ~== [1e-5] 0.0);
    if (f > 0)
      xmax = x;
    else
      xmin = x;
    x -= f / (norm * (1 - a * tanThetao));
  }
  return float2(
           monte_carlo::erfInverse(x),
           monte_carlo::erfInverse(2 * xi1 - 1),
         );
}

// The Smith normal PDF.
@(pure macro)
export float smithNormalPDF(const distribution this [[anno::unused()]], const float2 alpha, const float3 wm) {
  return wm.z > 0.0 ? smithSlopePDF(this, -wm.xy / (wm.z * alpha + EPSILON)) / (alpha.x * alpha.y * #pow(wm.z, 4) + EPSILON) : 0.0;
}

/// The Smith visible normal sampling function.
@(pure)
export float3 smithVisibleNormalSample(
  const distribution this,
  const float xi0,    ///< A canonical random number in `[0,1]`
  const float xi1,    ///< A canonical random number in `[0,1]`
  const float2 alpha, ///< The squared roughness 
  const float3 wo,    ///< The outgoing direction
) {
  const auto w11(normalize(float3(alpha * wo.xy, wo.z)));
  const auto sinTheta(length(w11.xy));
  const auto cosPhi(w11.x / sinTheta);
  const auto sinPhi(w11.y / sinTheta);
  const auto m11(smithVisibleSlopeSample(this, xi0, xi1, w11.z));
  const auto m(float2(alpha.x * dot(float2(cosPhi, -sinPhi), m11), //
                      alpha.y * dot(float2(sinPhi, +cosPhi), m11)));
  return #all(isfinite(m)) ? normalize(float3(-m, 1)) : wo.z == 0 ? normalize(wo) : float3(0, 0, 1);
}

/// The Blinn distribution.
export struct distribution_blinn: distribution {};

/// The Blinn normal first-quadrant sampling function.
@(pure)
export void blinnNormalFirstQuadrantSample(
  const float xi0, ///< A canonical random number in `[0,1]`
  const float xi1, ///< A canonical random number in `[0,1]`
  const float2 e,  ///< The exponent
  &float phi,      ///< The output azimuth angle
  &float cosTheta, ///< The output zenith angle cosine
) {
  if (e.x == e.y) {
    *phi = $HALF_PI * xi0;
    *cosTheta = #pow(xi1, 1 / (1 + e.x));
  } else {
    *phi = #atan(#sqrt((1 + e.x) / (1 + e.y)) * #tan($HALF_PI * xi0));
    *cosTheta = #pow(xi1, 1 / (1 + e.x * (cosPhi := #cos(*phi)) * cosPhi + e.y * (sinPhi := #sin(*phi)) * sinPhi));
  }
}

/// The Blinn normal sampling function.
@(pure)
export float3 blinnNormalSample(
  const float xi0, ///< A canonical random number in `[0,1]`
  const float xi1, ///< A canonical random number in `[0,1]`
  const float2 e,  ///< The exponent
) {
  float phi = 0;
  float cosTheta = 0;
  if (xi0 < 0.25) {
    blinnNormalFirstQuadrantSample(4 * xi0, xi1, e, &phi, &cosTheta);
  } else if (xi0 < 0.5) {
    blinnNormalFirstQuadrantSample(4 * (0.5 - xi0), xi1, e, &phi, &cosTheta), phi = $PI - phi;
  } else if (xi0 < 0.75) {
    blinnNormalFirstQuadrantSample(4 * (xi0 - 0.5), xi1, e, &phi, &cosTheta), phi += $PI;
  } else {
    blinnNormalFirstQuadrantSample(4 * (1 - xi0), xi1, e, &phi, &cosTheta), phi = $TWO_PI - phi;
  }
  return float3(#sqrt(1 - cosTheta * cosTheta + EPSILON) * float2(#cos(phi), #sin(phi)), cosTheta);
}

/// The tag to identify microfacet shadowing functions.
export tag shadowing;

/// The Smith shadowing function. (This is the principled correct solution!)
export struct shadowing_smith: default shadowing {};

/// The V-cavities shadowing function. (This is the older simpler approximation!)
export struct shadowing_vcavities: shadowing {};

@(foreign pure)
double lgamma(double x);

/// The beta function for Smith shadowing in transmission calculations.
@(pure)
export double beta(const double x, const double y) = #exp(lgamma(x) + lgamma(y) - lgamma(x + y));

} // namespace microfacet

struct microfacet_bsdf: bsdf {
  /// The roughness in `[0,1]^2`.
  const float2 roughness;

  /// The geometric mean roughness.
  const float roughness0 = #sqrt(#prod(roughness));

  /// The roughness squared in `[EPSILON,1]^2`. 
  ///
  /// \note 
  /// This is the effective roughness parameter that is actually 
  /// used in microfacet equations. It is squared for perceptual linearity,
  /// meaning that adjusting the `roughness` parameter more closely tracks
  /// qualitative changes in the apparent roughness of the BSDF.
  ///
  const float2 alpha = clamp(roughness * roughness, EPSILON, 1.0);

  /// The tint.
  $(color | float) tint;

  /// The multiscatter tint, or `none` for no multiscatter.
  $(?(color | float)) multiscatter_tint = none;

  /// The tangent direction for orienting anistropic roughness.
  float3 tangent_u = $state.texture_tangent_u[0];

  /// The scatter mode.
  const scatter_mode mode = scatter_reflect;

  /// The microfacet distribution.
  const microfacet::distribution distribution = microfacet::distribution();

  /// The microfacet shadowing technique.
  const microfacet::shadowing shadowing = microfacet::shadowing();

  /// The flags.
  const int _flags = int(mode) | DF_GLOSSY;
};

@(pure noinline)
auto scatterEvaluate(const &microfacet_bsdf this, inline const &ScatterEvaluateParameters params) {
  auto reflectChance(scatterReflectChance(this.mode));
  auto effectiveMode(this.mode & mode);
  preserve tangent_u;
  tangent_u = this.tangent_u;
  return ScatterEvaluateResult(isBlack: true) if (!recalculateTangentSpace(params) || effectiveMode == scatter_none);
  // If thin walled and the effective mode is to transmit, flip wi into the upper 
  // hemisphere and pretend like the effective mode is to reflect.
  preserve wi, mode;
  if (thin_walled && effectiveMode == scatter_transmit) {
    reflectChance = 1 - reflectChance;
    effectiveMode = scatter_reflect;
    mode = scatter_reflect; // Necessary for `halfDirection()` call below
    wi.z = -wi.z;
  }
  const auto cosThetao(#abs(wo.z));
  const auto cosThetai(#abs(wi.z));
  const auto wm(halfDirection(params));
  const auto dotWoWm(#sum(wo * wm));
  const auto dotWiWm(#sum(wi * wm));
  if $(this.distribution <: microfacet::distribution_blinn) {
    const auto e(2 / (this.alpha * this.alpha + EPSILON));
    const auto D(#pow(wm.z, (e.x * wm.x * wm.x + e.y * wm.y * wm.y) / (1 - wm.z * wm.z + EPSILON)) / $TWO_PI);
    const auto norm1(#sqrt(#prod(1 + e)));
    const auto norm2(#sqrt(#prod(2 + e)));
    const auto G(#min(1, 2 * wm.z * #min(#abs(cosThetao / dotWoWm), //
                                         #abs(cosThetai / dotWiWm))));
    if (effectiveMode == scatter_reflect) {
      const auto pdf(norm1 * D / (4 * float2(dotWoWm, dotWiWm) + EPSILON));
      const auto f(norm2 * D * G / (4 * cosThetao + EPSILON));
      auto result(ScatterEvaluateResultWithMultiscatter(this, f, pdf, cosThetao, cosThetai, this.roughness0, "simple_glossy_bsdf"));
      result.f *= shadingNormalCorrection if (isImportance);
      result.f *= reflectChance;
      result.pdf *= reflectChance;
      return result;
    } else {
      // TODO
      return ScatterEvaluateResult(isBlack: true) if (!((dotWoWm > 0) & (dotWiWm < 0)));
    }
  } else {
    const auto D(microfacet::smithNormalPDF(this.distribution, this.alpha, wm));
    const auto lambdao(microfacet::smithLambda(this.distribution, cosThetao / length(this.alpha * wo.xy)));
    const auto lambdai(microfacet::smithLambda(this.distribution, cosThetai / length(this.alpha * wi.xy)));
    const auto projAreao((1 + lambdao) * cosThetao);
    const auto projAreai((1 + lambdai) * cosThetai);
    const auto G = return_from {
      if $(this.shadowing <: microfacet::shadowing_smith) {
        return effectiveMode == scatter_reflect     //
               ? float(1 / (1 + lambdao + lambdai)) //
               : float(microfacet::beta(1 + lambdao, 1 + lambdai));
      } else {
        // V-cavities
        return #min(1, 2 * wm.z * #min(#abs(cosThetao / dotWoWm), //
                                       #abs(cosThetai / dotWiWm)));
      }
    };
    if (effectiveMode == scatter_reflect) {
      const auto lutName(this.distribution <: microfacet::distribution_ggx ? "microfacet_ggx_smith_bsdf" : "microfacet_beckmann_smith_bsdf");
      const auto pdf(D / (4 * float2(projAreao, projAreai) + EPSILON));
      const auto f(D * G / (4 * cosThetao + EPSILON));
      auto result(ScatterEvaluateResultWithMultiscatter(this, f, pdf, cosThetao, cosThetai, this.roughness0, lutName));
      result.f *= shadingNormalCorrection if (isImportance);
      result.f *= reflectChance;
      result.pdf *= reflectChance;
      return result;
    } else {
      return ScatterEvaluateResult(isBlack: true) if (!((dotWoWm > 0) & (dotWiWm < 0)));
      const auto jac(float2(specular::refractionHalfVectorJacobian(wo, wi, ior), //
                            specular::refractionHalfVectorJacobian(wi, wo, 1 / ior)));
      const auto pdf(D * jac * float2(dotWoWm, -dotWiWm) / (float2(projAreao, projAreai) + EPSILON));
      const auto f(D * G * jac[0] * dotWoWm / (cosThetao + EPSILON));
      auto result(ScatterEvaluateResult(f: this.tint * f, pdf: pdf));
      result.f *= shadingNormalCorrection if (isImportance);
      result.f *= 1 - reflectChance;
      result.pdf *= 1 - reflectChance;
      return result;
    }
  }
  return ScatterEvaluateResult(isBlack: true);
}

@(pure noinline)
auto scatterSample(const &microfacet_bsdf this, inline const &ScatterSampleParameters params) {
  preserve tangent_u;
  tangent_u = this.tangent_u;
  auto tbn(recalculateTangentSpace(params));
  if (!tbn)
    return ScatterSampleResult();
  // Decide whether to reflect or transmit. NOTE: This is not Fresnel-weighted, it is either deterministic or 50/50.
  const auto mode(monte_carlo::boolSample(&xi.z, scatterReflectChance(this.mode)) //
                  ? scatter_reflect                                               //
                  : scatter_transmit);
  if (mode == scatter_reflect || thin_walled) {
    if (result := ScatterSampleResultWithMultiscatter(this, &xi, *tbn)) {
      if (mode == scatter_transmit)
        return ScatterSampleResult(wi: result.wi * float3(+1, +1, -1), mode: mode);
      return *result;
    }
  }
  // Otherwise, sample a microsurface normal direction from the distribution, then either reflect or
  // refract through the normal depending on whether we decided to reflect or transmit. Note: The Blinn 
  // distribution is not a closed-form scale-invariant Smith distribution, so it has a separate normal 
  // sampling routine.
  const auto wm = return_from {
    if $(this.distribution <: microfacet::distribution_blinn) {
      return microfacet::blinnNormalSample(xi.x, xi.y, 2 / (this.alpha * this.alpha + EPSILON));
    } else {
      return microfacet::smithVisibleNormalSample(this.distribution, xi.x, xi.y, this.alpha, wo);
    }
  };
  const auto wi = return_from {
    if (mode == scatter_reflect) {
      return specular::reflect(wo, wm);
    } else {
      // If thin walled, reflect in the upper hemisphere then flip wi to the lower hemisphere.
      if (thin_walled) {
        return specular::reflect(wo, wm) * float3(+1, +1, -1);
      } else {
        return specular::refract(wo, wm, ior);
      }
    }
  };
  return ScatterSampleResult(wi: normalize((*tbn) * wi), mode: mode);
}

@(macro)
auto makeMicrofacetBSDF(
  const float roughness_u,
  const float roughness_v = roughness_u,
  const $(color | float) tint = 1.0,
  const $(?(color | float)) multiscatter_tint = none,
  const float3 tangent_u = $state.texture_tangent_u[0],
  const scatter_mode mode = scatter_reflect,
  const string handle = "" [[anno::unused()]],
  const microfacet::distribution distribution = microfacet::distribution(),
  const microfacet::shadowing shadowing = microfacet::shadowing(),
) {
  if ((roughness_u > 0) | (roughness_v > 0)) {
    return microfacet_bsdf(
             roughness: float2(roughness_u, roughness_v),
             tint: tint,
             multiscatter_tint: multiscatter_tint,
             tangent_u: normalize(tangent_u),
             mode: mode,
             distribution: distribution,
             shadowing: shadowing,
           );
  } else {
    return specular_bsdf(tint: tint, mode: mode);
  }
}
//--}

export auto simple_glossy_bsdf(*) = makeMicrofacetBSDF(distribution: microfacet::distribution_blinn(), shadowing: microfacet::shadowing_vcavities());

export auto microfacet_ggx_smith_bsdf(*) = makeMicrofacetBSDF(distribution: microfacet::distribution_ggx(), shadowing: microfacet::shadowing_smith());

export auto microfacet_ggx_vcavities_bsdf(*) = makeMicrofacetBSDF(distribution: microfacet::distribution_ggx(), shadowing: microfacet::shadowing_vcavities());

export auto microfacet_beckmann_smith_bsdf(*) = makeMicrofacetBSDF(distribution: microfacet::distribution_beckmann(), shadowing: microfacet::shadowing_smith());

export auto microfacet_beckmann_vcavities_bsdf(*) = makeMicrofacetBSDF(distribution: microfacet::distribution_beckmann(), shadowing: microfacet::shadowing_vcavities());

//--{ measured_bsdf
export bool bsdf_measurement_isvalid(const bsdf_measurement measurement) = bool(measurement.buffer);

export struct measured_bsdf: bsdf {
  bsdf_measurement measurement;

  float multiplier = 1.0;

  scatter_mode mode = scatter_reflect;

  string handle = "";
};

@(macro)
auto scatterEvaluate(const &measured_bsdf this [[anno::unused()]], const &ScatterEvaluateParameters params [[anno::unused()]]) {
  // TODO
  return ScatterEvaluateResult(isBlack: true);
}

@(macro)
auto scatterSample(const &measured_bsdf this [[anno::unused()]], const &ScatterSampleParameters params [[anno::unused()]]) {
  // TODO
  return ScatterSampleResult();
}
//--}

//--{ tint
/// A 1-value tint.
struct tint1: bsdf, edf, hair_bsdf {
  /// The tint multiplier.
  $(color | float) tint;

  /// The base `bsdf`, `edf`, or `hair_bsdf`.
  auto base;

  /// The flags.
  const int _flags = base._flags;
};

/// A 2-value tint.
struct tint2: bsdf {
  /// The tint multiplier on reflection.
  $(color | float) reflection_tint;

  /// The tint multiplier on transmission.
  $(color | float) transmission_tint;

  /// The base `bsdf`.
  bsdf base;

  /// The flags.
  const int _flags = base._flags;
};

/// Construct 1-value tint of the given `bsdf`.
@(macro)
export auto tint(const auto tint, const bsdf base) = tint1(tint, base);

/// Construct 1-value tint of the given `edf`.
@(macro)
export auto tint(const auto tint, const edf base) = tint1(tint, base);

/// Construct 1-value tint of the given `hair_bsdf`.
@(macro)
export auto tint(const auto tint, const hair_bsdf base) = tint1(tint, base);

/// Construct 2-value tint of the given `bsdf`.
@(macro)
export auto tint(const auto reflection_tint, const auto transmission_tint, const bsdf base) = tint2(reflection_tint, transmission_tint, base);

@(macro)
auto scatterEvaluate(const &tint1 this, const &ScatterEvaluateParameters params) {
  auto result(scatterEvaluate(visit &this.base, params));
  if (!result.isBlack)
    result.f *= this.tint;
  return result;
}

@(macro)
auto scatterEvaluate(const &tint2 this, const &ScatterEvaluateParameters params) {
  auto result(scatterEvaluate(visit &this.base, params));
  if (!result.isBlack) {
    if (params.mode == scatter_reflect) {
      result.f *= this.reflection_tint;
    } else {
      result.f *= this.transmission_tint;
    }
  }
  return result;
}

@(macro)
auto scatterSample(const &tint1 this, const &ScatterSampleParameters params) {
  auto result(scatterSample(visit &this.base, params));
  if ((result.mode != scatter_none) & bool(result.deltaValue))
    *result.deltaValue *= this.tint;
  return result;
}

@(macro)
auto scatterSample(const &tint2 this, const &ScatterSampleParameters params) {
  auto result(scatterSample(visit &this.base, params));
  if ((result.mode != scatter_none) & bool(result.deltaValue)) {
    if (params.mode == scatter_reflect) {
      *result.deltaValue *= this.reflection_tint;
    } else {
      *result.deltaValue *= this.transmission_tint;
    }
  }
  return result;
}
//--}

//--{ weighted_layer, color_weighted_layer
export struct weighted_layer: bsdf {
  /// The weight. 
  $(color | float) weight;

  /// The layer BSDF.
  bsdf layer = bsdf();

  /// The base BSDF.
  bsdf base = bsdf();

  /// The normal to use for the layer.
  float3 normal = $state.normal;

  /// The chance of sampling the layer BSDF.
  ///
  /// \note
  /// If the weight is a `float`, then the chance is the same
  /// as the weight. However, if the weight is a `color`, we
  /// have to average it down to a single probability.
  ///
  float chance = average(weight);

  /// The flags.
  const int _flags = layer._flags | base._flags;

  finalize {
    weight = saturate(weight);
    chance = saturate(chance);
  }
};

@(macro)
auto scatterEvaluate(const &weighted_layer this, inline const &ScatterEvaluateParameters params) {
  auto result0(scatterEvaluate(visit &this.base, params));
  preserve normal;
  normal = this.normal;
  auto result1(scatterEvaluate(visit &this.layer, params));
  return ScatterEvaluateResult(f: lerp(result0.f, result1.f, this.weight), pdf: lerp(result0.pdf, result1.pdf, this.chance), isBlack: result0.isBlack & result1.isBlack);
}

@(macro)
auto scatterSample(const &weighted_layer this, inline const &ScatterSampleParameters params) {
  if (monte_carlo::boolSample(&xi.w, this.chance)) {
    preserve normal;
    normal = this.normal;
    return scatterSample(visit &this.layer, params);
  } else {
    return scatterSample(visit &this.base, params);
  }
}

/// The `color_weighted_layer` is also implemented by the `weighted_layer`.
export typedef weighted_layer color_weighted_layer;
//--}

//--{ thin_film

/// A thin film layer.
///
/// > Add reflective thin-film interference color to an elemental or
/// > compound BSDF.
///
export struct thin_film: bsdf {
  /// The thickness in nanometers.
  $(color | float) thickness;

  /// The index of refraction.
  $(color | float) ior;

  /// The base BSDF.
  bsdf base = bsdf();

  /// The flags.
  const int _flags = base._flags;
};

@(macro)
auto scatterEvaluate(const &thin_film this, const &ScatterEvaluateParameters params) {
  auto result(scatterEvaluate(visit &this.base, params));
  if (!result.isBlack && params.mode == scatter_reflect) {
    // TODO
    return ScatterEvaluateResult(f: result.f, pdf: result.pdf);
  } else {
    return result;
  }
}

@(macro)
auto scatterSample(const &thin_film this, const &ScatterSampleParameters params) {
  auto result(scatterSample(visit &this.base, params));
  if ((result.mode == scatter_reflect) & bool(result.deltaValue)) {
    // TODO
  }
  return result;
}
//--}

//--{ fresnel_factor

/// A fresnel factor.
///
/// > Modifier weighting a base BSDF based on the Fresnel reflection 
/// > equation for a complex number IOR, comprising a real number IOR 
/// > and an extinction coefficient. This modifier is useful to model
/// > the reflectance behavior of conductors and semi-conductors.
///
export struct fresnel_factor: bsdf {
  /// The index of refraction.
  $(color | float) ior;

  /// The extinction coefficient.
  $(color | float) extinction_coefficient;

  /// The base BSDF.
  bsdf base = bsdf();

  /// The flags.
  const int _flags = base._flags;
};

@(macro)
auto scatterEvaluate(const &fresnel_factor this, const &ScatterEvaluateParameters params) {
  auto result(scatterEvaluate(visit &this.base, params));
  if (!result.isBlack && params.mode == scatter_reflect) {
    return ScatterEvaluateResult(
             f: specular::conductorFresnel(#abs(dot(params.wo, halfDirection(params))), 1.0 / complex(this.ior, this.extinction_coefficient)) * result.f,
             pdf: result.pdf,
           );
  }
  return result;
}

@(macro)
auto scatterSample(const &fresnel_factor this, const &ScatterSampleParameters params) {
  auto result(scatterSample(visit &this.base, params));
  if ((result.mode == scatter_reflect) & bool(result.deltaValue)) {
    *result.deltaValue *= specular::conductorFresnel(#abs(dot(params.wo, halfDirection(params, &result))), 1.0 / complex(this.ior, this.extinction_coefficient));
  }
  return result;
}
//--}

//--{ directional_factor
export struct directional_factor: bsdf {
  /// The normal tint.
  ///
  /// > Color scaling factor at the normal.
  ///
  $(color | float) normal_tint = 1.0;

  /// The grazing tint.
  /// 
  /// > Color scaling factor at the grazing angle.
  ///
  $(color | float) grazing_tint = 1.0;

  /// The exponent.
  ///
  /// > Exponent for directional factor. Default value (5.0) is 
  /// > from Schlick's approximation.
  ///
  float exponent = 5.0;

  /// The base BSDF.
  ///
  /// > Base BSDF to be modified by directional factor.
  ///
  bsdf base = bsdf();

  /// The flags.
  const int _flags = base._flags;
};

@(macro)
auto scatterEvaluate(const &directional_factor this, const &ScatterEvaluateParameters params) {
  auto result(scatterEvaluate(visit &this.base, params));
  if (!result.isBlack && params.mode == scatter_reflect) {
    return ScatterEvaluateResult(f: specular::schlickFresnel(dot(params.wo, halfDirection(params)), this.normal_tint, this.grazing_tint, this.exponent) * result.f, pdf: result.pdf);
  } else {
    return result;
  }
}

@(macro)
auto scatterSample(const &directional_factor this, const &ScatterSampleParameters params) {
  auto result(scatterSample(visit &this.base, params));
  if ((result.mode == scatter_reflect) & bool(result.deltaValue)) {
    *result.deltaValue *= specular::schlickFresnel(dot(params.wo, halfDirection(params, &result)), this.normal_tint, this.grazing_tint, this.exponent);
  }
  return result;
}
//--}

//--{ measured_curve_factor
export struct measured_curve_factor: bsdf {
  /// The curve values.
  ///
  /// > Measured data for the reflection behavior. A 1-d function 
  /// > measured in the pre-image range from zero to pi/2 with equally 
  /// > spaced measured reflectance values.
  ///
  color[] curve_values;

  /// The base BSDF.
  ///
  /// > Base BSDF to be modified by the measured reflectance curve.
  ///
  bsdf base = bsdf();

  /// The flags.
  const int _flags = base._flags;
};

@(macro)
auto scatterEvaluate(const &measured_curve_factor this, const &ScatterEvaluateParameters params) {
  auto result(scatterEvaluate(visit &this.base, params));
  if (!result.isBlack && params.mode == scatter_reflect) {
    // TODO
    return ScatterEvaluateResult(f: result.f, pdf: result.pdf);
  } else {
    return result;
  }
}

@(macro)
auto scatterSample(const &measured_curve_factor this, const &ScatterSampleParameters params) {
  auto result(scatterSample(visit &this.base, params));
  if ((result.mode == scatter_reflect) & bool(result.deltaValue)) {
    // TODO
  }
  return result;
}
//--}

//--{ measured_factor
export struct measured_factor: bsdf {
  /// The values.
  ///
  /// > Measured data of type color for the reflection behavior. A 2-d 
  /// > function measured in the pre-image range `[0,pi/2]^2` with equally
  /// > spaced reflectance values, where the texture-space u-coordinate 
  /// > corresponds to the angle alpha between the incoming direction and 
  /// > the half-vector h from the microfacet model, and the texture-space
  /// > v-coordinate corresponds to the angle beta between the half-vector 
  /// > h and the shading surface normal.
  ///
  texture_2d values;

  /// The base BSDF.
  ///
  /// > Base BSDF to be modified by the measured reflectance values.
  ///
  bsdf base = bsdf();

  /// The flags.
  const int _flags = base._flags;
};

@(macro)
auto scatterEvaluate(const &measured_factor this, const &ScatterEvaluateParameters params) {
  auto result(scatterEvaluate(visit &this.base, params));
  if (!result.isBlack && params.mode == scatter_reflect) {
    // TODO
    return ScatterEvaluateResult(f: result.f, pdf: result.pdf);
  } else {
    return result;
  }
}

@(macro)
auto scatterSample(const &measured_factor this, const &ScatterSampleParameters params) {
  auto result(scatterSample(visit &this.base, params));
  if ((result.mode == scatter_reflect) & bool(result.deltaValue)) {
    // TODO
  }
  return result;
}
//--}

//--{ fresnel_layer, color_fresnel_layer
export struct fresnel_layer: bsdf {
  /// The index of refraction.
  $(color | float) ior;

  /// The weight.
  $(color | float) weight = 1.0;

  /// The layer BSDF.
  bsdf layer = bsdf();

  /// The base BSDF.
  bsdf base = bsdf();

  /// The normal to use for the layer.
  float3 normal = $state.normal;

  /// The precomputed average index of refraction.
  const float _averageIOR = average(ior);

  /// The precomputed average weight.
  const float _averageWeight = average(weight);

  /// The flags.
  const int _flags = layer._flags | base._flags;
};

@(macro)
auto scatterEvaluate(const &fresnel_layer this, inline const &ScatterEvaluateParameters params) {
  const auto cosThetao(dot(wo, this.normal) * #sign(this.normal.z));
  const auto cosThetai(dot(wi, this.normal) * #sign(this.normal.z));
  if ((cosThetao < EPSILON)                                 //
      | ((mode == scatter_reflect) & (cosThetai < EPSILON)) //
      | ((mode == scatter_transmit) & (cosThetai > -EPSILON)))
    return ScatterEvaluateResult(isBlack: true);
  const auto result0(scatterEvaluate(visit &this.base, params));
  const auto result1 = return_from {
    preserve normal, ior;
    normal = this.normal, ior = 1.0 / this._averageIOR; // Assume IOR of 1.4 => relative IOR of 1 / 1.4
    return scatterEvaluate(visit &this.layer, params);
  };
  if (result0.isBlack & result1.isBlack) {
    return ScatterEvaluateResult(isBlack: true);
  } else {
    return ScatterEvaluateResult(
             f: lerp(
               result0.f,
               result1.f,
               this.weight * specular::dielectricFresnel(dot(wo, halfDirection(params)), 1 / this.ior),
             ),
             pdf: lerp(
               result0.pdf,
               result1.pdf,
               this._averageWeight * specular::schlickFresnel(float2(cosThetao, cosThetai), specular::schlickF0(this._averageIOR)),
             ),
           );
  }
}

@(macro)
auto scatterSample(const &fresnel_layer this, inline const &ScatterSampleParameters params) {
  const auto cosTheta(dot(wo, this.normal) * #sign(this.normal.z));
  if (cosTheta < EPSILON)
    return ScatterSampleResult();
  const auto chance(this._averageWeight * specular::schlickFresnel(cosTheta, specular::schlickF0(this._averageIOR)));
  if (monte_carlo::boolSample(&xi.z, chance)) {
    preserve normal, ior;
    normal = this.normal, ior = 1.0 / this._averageIOR; // Assume IOR of 1.4 => relative IOR of 1/1.4
    auto result(scatterSample(visit &this.layer, params));
    *result.deltaValue *= this.weight * specular::dielectricFresnel(dot(wo, halfDirection(params, &result)), 1 / this.ior) / chance if (result.deltaValue);
    return result;
  } else {
    auto result(scatterSample(visit &this.base, params));
    *result.deltaValue *= (1 - this.weight * specular::dielectricFresnel(dot(wo, halfDirection(params, &result)), 1 / this.ior)) / (1 - chance) if (result.deltaValue);
    return result;
  }
}

export typedef fresnel_layer color_fresnel_layer;
//--}

// TODO custom_curve_layer, color_custom_curve_layer

// TODO measured_curve_layer, color_measured_curve_layer

//--{ normalized_mix, clamped_mix, unbounded_mix
tag component;

export struct bsdf_component: component {
  float weight = 0.0;
  bsdf component = bsdf();
  float chance = weight; // NOTE: Non-standard!
};
export struct edf_component: component {
  float weight = 0.0;
  edf component = edf();
  float chance = weight; // NOTE: Non-standard!
};
export struct vdf_component: component {
  float weight = 0.0;
  vdf component = vdf();
  float chance = weight; // NOTE: Non-standard!
};

struct component_mix: bsdf, edf, vdf {
  component[] components;

  int _flags = 0;
};

@(macro)
export auto normalized_mix(component[<N>] components) {
  int _flags(0);
  float total_weight(0);
  float total_chance(0);
  for (int i = 0; i < N; i++) {
    auto component(&components[i]);
    component.weight = #max(component.weight, 0.0);
    component.chance = #max(component.chance, 0.0);
    total_weight += component.weight;
    total_chance += component.chance;
    _flags |= component.component._flags;
  }
  if (total_weight > 1.0)
    total_weight = 1.0 / total_weight;
  else
    total_weight = 1.0;
  total_chance = 1.0 / total_chance if (total_chance > 0.0);
  for (int i = 0; i < N; i++) {
    auto component(&components[i]);
    component.weight *= total_weight;
    component.chance *= total_chance;
  }
  return component_mix(components, _flags);
}

@(macro)
export auto clamped_mix(component[<N>] components) {
  int _flags(0);
  float total_weight(0);
  float total_chance(0);
  for (int i = 0; i < N; i++) {
    auto component(&components[i]);
    component.weight = #max(component.weight, 0.0);
    component.chance = #max(component.chance, 0.0);
    if (total_weight + component.weight < 1.0) {
      total_weight += component.weight;
      total_chance += component.chance;
      _flags |= component.component._flags;
    } else {
      // MDL specification:
      // Once a component weight would cause the sum to exceed 1.0, 
      // it is replaced with the result of subtracting the sum from 1.0.
      // All subsequent weights are then set to 0.0.
      component.weight = 1.0 - total_weight;
      for (int j = i + 1; j < N; j++) {
        components[j].weight = 0;
        components[j].chance = 0;
      }
      break;
    }
  }
  total_chance = 1.0 / total_chance if (total_chance > 0.0);
  for (int i = 0; i < N; i++) {
    components[i].chance *= total_chance;
  }
  return component_mix(components, _flags);
}

@(macro)
export auto unbounded_mix(component[<N>] components) {
  int _flags(0);
  float total_chance(0);
  for (int i = 0; i < N; i++) {
    auto component(&components[i]);
    component.weight = #max(component.weight, 0.0);
    component.chance = #max(component.chance, 0.0);
    total_chance += component.chance;
    _flags |= component._flags;
  }
  total_chance = 1.0 / total_chance if (total_chance > 0.0);
  for (int i = 0; i < N; i++) {
    components[i].chance *= total_chance;
  }
  return component_mix(components, _flags);
}

@(macro)
auto scatterEvaluate(const &component_mix this, const &ScatterEvaluateParameters params) {
  auto result(ScatterEvaluateResult(f: color(0), isBlack: true));
  for (int i = 0; i < #num(this.components); i++) {
    visit component in this.components[i] { // In general this is a union!
      auto component_result(scatterEvaluate(visit &component.component, params));
      if (!component_result.isBlack) {
        result.pdf += component.chance * component_result.pdf;
        result.f += component.weight * component_result.f;
        result.isBlack = false;
      }
    }
  }
  return result;
}

@(macro)
auto scatterSample(const &component_mix this, const &ScatterSampleParameters params) {
  const auto xi(&params.xi.z);
  for (int i = 0; i < #num(this.components); i++) {
    visit component in this.components[i] { // In general this is a union!
      if (!(*xi < component.chance)) {
        *xi -= component.chance;
      } else {
        *xi /= component.chance;
        auto result(scatterSample(visit &component.component, params));
        if ((result.mode != scatter_none) & bool(result.deltaValue))
          *result.deltaValue *= component.weight;
        return result;
      }
    }
  }
  return ScatterSampleResult();
}
//--}

export struct anisotropic_vdf: vdf {
  float directional_bias = 0.0;

  void handle = "";

  static const int _flags = 0;

  finalize {
    directional_bias = #max(directional_bias, -0.999);
    directional_bias = #min(directional_bias, +0.999);
  }
};

@(macro)
auto scatterEvaluate(const &anisotropic_vdf this, inline const &ScatterEvaluateParameters params) {
  const auto cosTheta = dot(wo, wi);
  const auto g = this.directional_bias;
  const auto p = (1.0 - g * g) / (4.0 * $PI * (denom := 1.0 + g * g + 2.0 * g * cosTheta) * #sqrt(denom));
  return ScatterEvaluateResult(f: p, pdf: float2(p));
}

@(macro)
auto scatterSample(const &anisotropic_vdf this, inline const &ScatterSampleParameters params) {
  const auto g = this.directional_bias;
  const auto cosTheta = #abs(g) < 0.001    //
                        ? 1.0 - 2.0 * xi.x //
                        : -(1.0 + g * g - #pow((1.0 - g * g) / (1.0 + g * (1.0 - 2.0 * xi.x)), 2)) / (2.0 * g);
  const auto sinTheta = #sqrt(#max(0.0, 1.0 - cosTheta * cosTheta));
  const auto phi = 2.0 * $PI * xi.y;
  return ScatterSampleResult(wi: orthonormalBasis(wo) * float3(sinTheta * #cos(phi), sinTheta * #sin(phi), cosTheta), mode: scatter_reflect_transmit);
}

@(macro)
export int _scatterEvaluate(
  const &_MaterialInstance instance,
  const &float3 woWorld, ///< The outgoing direction in world space
  const &float3 wiWorld, ///< The incoming direction in world space
  const &float pdfFwd,   ///< output: The PDF of sampling `wi` from `wo`
  const &float pdfRev,   ///< output: The PDF of sampling `wo` from `wi`
  const &float f,        ///< output: The scattering function
) {
  auto params = ScatterEvaluateParameters(
    isImportance: (instance.flags & 1) != 0,
    ior: 1.0 / instance.ior,
    wo0: normalize((*woWorld) * instance.tangent_to_world),
    wi0: normalize((*wiWorld) * instance.tangent_to_world),
    normal: normalize(instance.geometry.normal),
    thin_walled: instance.ptr.thin_walled,
  );
  auto result = #is_default(instance.ptr.backface) || !params.hitBackface         //
                ? scatterEvaluate(visit &instance.ptr.surface.scattering, &params) //
                : scatterEvaluate(visit &instance.ptr.backface.scattering, &params);
  visit result in result {
    if (result.isBlack) {
      *pdfFwd = 0.0;
      *pdfRev = 0.0;
      for (int i = 0; i < $WAVELENGTH_BASE_MAX; i++)
        f[i] = 0.0;
    } else {
      *pdfFwd = result.pdf[0];
      *pdfRev = result.pdf[1];
      if (#typeof(result.f) == float) {
        for (int i = 0; i < $WAVELENGTH_BASE_MAX; i++)
          f[i] = result.f;
      } else {
        #memcpy(f, &result.f, #sizeof(float) * $WAVELENGTH_BASE_MAX);
      }
    }
    return !result.isBlack;
  }
}

@(macro)
export int _scatterSample(
  const &_MaterialInstance instance,
  const &float4 xi,      ///< The canonical random sample in `[0,1]^4`
  const &float3 woWorld, ///< The outgoing direction in world space
  const &float3 wiWorld, ///< output: The incoming direction in world space
  const &float pdfFwd,   ///< output: The PDF of sampling `wi` from `wo`
  const &float pdfRev,   ///< output: The PDF of sampling `wo` from `wi`
  const &float f,        ///< output: The scattering function
  const &int isDelta,    ///< output: Is delta direction?
) {
  auto wo = normalize((*woWorld) * instance.tangent_to_world);
  auto params = ScatterSampleParameters(
    isImportance: (instance.flags & 1) != 0,
    xi: *xi,
    wo0: wo,
    ior: 1.0 / instance.ior,
    normal: normalize(instance.geometry.normal),
    thin_walled: instance.ptr.thin_walled,
  );
  auto result = #is_default(instance.ptr.backface) || !params.hitBackface       //
                ? scatterSample(visit &instance.ptr.surface.scattering, &params) //
                : scatterSample(visit &instance.ptr.backface.scattering, &params);
  visit result in result {
    const auto wi = #select(params.hitBackface, -result.wi, +result.wi);
    if (result.mode == scatter_none || ((wo.z < 0.0) == (wi.z < 0.0)) != (result.mode == scatter_reflect)) {
      *pdfFwd = 0.0;
      *pdfRev = 0.0;
      for (int i = 0; i < $WAVELENGTH_BASE_MAX; i++)
        f[i] = 0.0;
      return false;
    }
    *wiWorld = normalize(instance.tangent_to_world * wi);
    if ((*isDelta = bool(result.deltaValue))) {
      *pdfFwd = 1.0;
      *pdfRev = 1.0;
      #memcpy(f, &*result.deltaValue, #sizeof(float) * $WAVELENGTH_BASE_MAX);
      return true;
    } else {
      return _scatterEvaluate(instance, woWorld, wiWorld, pdfFwd, pdfRev, f);
    }
  }
}

@(macro)
export float _volumeScatterEvaluate(
  const &_MaterialInstance instance,
  const &float3 woWorld, ///< The outgoing direction in world space
  const &float3 wiWorld, ///< The incoming direction in world space
) {
  auto params = ScatterEvaluateParameters(
    isImportance: 0,
    wo0: normalize(*woWorld),
    wi0: normalize(*wiWorld),
    hitBackface: false, // Not applicable for volume scattering
  );
  return scatterEvaluate(visit &instance.ptr.volume.scattering, &params).f;
}

@(macro)
export float _volumeScatterSample(
  const &_MaterialInstance instance,
  const &float4 xi,      ///< The canonical random sample in `[0,1]^4`
  const &float3 woWorld, ///< The outgoing direction in world space
  const &float3 wiWorld, ///< output: The incoming direction in world space
) {
  auto wo = normalize(*woWorld);
  auto params = ScatterSampleParameters(xi: *xi, wo0: wo, hitBackface: false);
  auto result = scatterSample(visit &instance.ptr.volume.scattering, &params);
  if (result.mode == scatter_none) {
    return 0.0;
  }
  *wiWorld = normalize(result.wi);
  return _volumeScatterEvaluate(instance, woWorld, wiWorld);
}
