// vim:foldmethod=marker:foldlevel=0:fmr=--{,--}
#smdl

using ::math import *;

export enum scatter_mode { scatter_none = 0, scatter_reflect = 1, scatter_transmit = 2, scatter_reflect_transmit = 3 };

/// Calculate the chance of reflection.
@(pure macro) float scatter_reflect_chance(const scatter_mode mode) {
  const auto refl_weight(#select((int(mode) & 1) != 0, 1.0, 0.0));
  const auto tran_weight(#select((int(mode) & 2) != 0, 1.0, 0.0));
  return refl_weight / (refl_weight + tran_weight);
}

/// An arbitrary epsilon for stabilizing scattering calculations.
const float SCATTER_EPS = 0.001;

/// An arbitrary chance for sampling diffusely in BSDFs with multiple-scattering.
const float MULTISCATTER_DIFFUSE_CHANCE = 0.2;

// NOTE: Non-standard! Used internally
export namespace monte_carlo {

export @(pure macro) float2 advance_low_discrepancy(const &float2 xi) = (*xi = frac(*xi + float2(0.75487766, 0.56984029)));

export @(pure macro) float3 advance_low_discrepancy(const &float3 xi) = (*xi = frac(*xi + float3(0.81917251, 0.67104360, 0.54970047)));

export @(pure macro) float4 advance_low_discrepancy(const &float4 xi) = (*xi = frac(*xi + float4(0.85667488, 0.73389185, 0.62870672, 0.53859725)));

export @(pure) bool bool_sample(const &float xi, const float chance) {
  if (*xi < chance) {
    *xi = (*xi / chance);
    return true;
  } else {
    *xi = (*xi - chance) / (1 - chance);
    return false;
  }
}

export @(pure) int uniform_wavelength_index_sample(const &float xi) {
  const int i(#min(int(*xi *= $WAVELENGTH_BASE_MAX), $WAVELENGTH_BASE_MAX - 1));
  *xi -= i;
  return i;
}

export @(pure noinline) float2 uniform_disk_sample(float2 xi) {
  xi = 2 * xi - 1;
  xi = #select(xi == 0, 1e-5, xi);
  const bool cond((absxi := #abs(xi), absxi.x > absxi.y));
  const float rad(#select(cond, xi.x, xi.y));
  const float phi(#select(cond, ($PI / 4) * xi.y / xi.x, ($PI / 2) - ($PI / 4) * xi.x / xi.y));
  return rad * float2(#cos(phi), #sin(phi));
}

export @(pure noinline) float3 cosine_hemisphere_sample(float2 xi) = float3((p := uniform_disk_sample(xi)), #sqrt(#max(1 - #sum(p * p), 0)));

} // namespace monte_carlo

// NOTE: Non-standard! Used internally
export namespace specular {

export @(pure macro) auto reflect(const float3 wi, const float3 wm) = 2 * #sum(wi * wm) * wm - wi;

export @(pure macro) auto refract(const float3 wi, const float3 wm, const float ior) {
  const auto cos_thetai(#sum(wi * wm));
  const auto cos2_thetai(#min(cos_thetai * cos_thetai, 1));
  const auto cos2_thetat(#max(1 - ior * ior * (1 - cos2_thetai), 0));
  const auto cos_thetat(#sqrt(cos2_thetat) * -#sign(cos_thetai));
  return -ior * wi + (ior * cos_thetai + cos_thetat) * wm;
}

export @(pure macro) auto refraction_half_vector(
  const float3 wo,
  const float3 wi,
  const float ior,
) = (vh := -ior * wo + wi) * #sign(vh.z);

export @(pure macro) auto refraction_half_vector_jacobian(
  const float3 wo,
  const float3 wi,
  const float ior,
) = #abs(#sum(wi * (vh := refraction_half_vector(wo, wi, ior)))) / ((vh2 := #sum(vh * vh)) * #sqrt(vh2));

export @(pure macro) auto schlick_F0(const auto ior) = #pow((ior - 1) / (ior + 1), 2);

export @(pure macro) auto schlick_fresnel(
  const auto cos_theta,
  const auto F0,
  const auto F90 = 1.0,
  const float exponent = 5,
) = F0 + (F90 - F0) * #pow(#max(1 - #abs(cos_theta), 0), exponent);

export @(pure) auto dielectric_fresnel(const float cos_thetai, const auto ior) {
  const auto cos2_thetat(1 - ior * ior * (1 - cos_thetai * cos_thetai));
  const auto cos_thetat(#sqrt(#max(cos2_thetat, 0)) * #sign(cos_thetai));
  const auto rs((ior * cos_thetai - cos_thetat) / (ior * cos_thetai + cos_thetat));
  const auto rp((cos_thetai - ior * cos_thetat) / (cos_thetai + ior * cos_thetat));
  return #min(0.5 * (rs * rs + rp * rp), 1.0);
}

} // namespace specular

/// Calculate the orthogonal right-handed tangent space from the 
/// given normal and tangent vectors.
@(pure noinline) float3x3 build_tangent_space(const float3 normal, const float3 tangent_u) {
  const auto tw(normalize(normal) * #sign(normal.z));
  const auto tu(normalize(tangent_u - dot(tangent_u, tw) * tw));
  const auto tv(normalize(cross(tw, tu)));
  return float3x3(tu, tv, tw);
}

struct scatter_evaluate_parameters {
  /// The reference outgoing direction in the natural tangent space.
  float3 wo0;

  /// The reference incoming direction in the natural tangent space.
  float3 wi0;

  /// The reference mode. 
  scatter_mode mode = (wo0.z < 0) == (wi0.z < 0) ? scatter_reflect : scatter_transmit;

  /// Hit backface?
  bool hit_backface = wo0.z < 0;

  /// Is thin walled?
  bool thin_walled = false;

  /// The relative upper-to-lower index of refraction.
  float ior = 1 / 1.4;

  /// The normal direction.
  float3 normal = float3(0, 0, 1);

  /// The tangent direction.
  float3 tangent_u = float3(1, 0, 0);

  /// The outgoing direction.
  float3 wo = wo0;

  /// The incoming direction.
  float3 wi = wi0;

  finalize {
    // If we hit the backface, flip everything so that `wo` 
    // is always in the upper hemisphere.
    if (hit_backface) {
      wo0 = -wo0;
      wi0 = -wi0;
      wo = -wo;
      wi = -wi;
      ior = 1 / ior;
    }
  }
};

struct scatter_evaluate_result {
  /// The Bidirectional Scattering Distribution Function (BSDF) evaluation.
  $(color | float) f = 0.0;

  /// The Probability Density Function (PDF) evaluations.
  /// - `pdf[0]` is the forward density of sampling `wi` given `wo`.
  /// - `pdf[1]` is the reverse density of sampling `wo` given `wi`.
  float2 pdf = float2(0.0);

  /// Is known to be black by construction? Faster than checking every 
  /// element of `f`!
  bool is_black = false;
};

@(pure noinline) bool recalculate_tangent_space(inline const &scatter_evaluate_parameters params) {
  auto tbn(build_tangent_space(normal, tangent_u));
  wo = wo0 * tbn;
  wi = wi0 * tbn;
  return ((wo.z < 0) == (wo0.z < 0)) & ((wi.z < 0) == (wi0.z < 0));
}

@(pure) float3 half_direction(inline const &scatter_evaluate_parameters params) {
  return normalize(mode == scatter_reflect ? wo + wi : specular::refraction_half_vector(wo, wi, ior));
}

struct scatter_sample_parameters {
  /// The primary outgoing direction in the natural geometric tangent space.
  float3 wo0;

  /// Hit backface?
  bool hit_backface = wo0.z < 0;

  /// Is thin walled?
  bool thin_walled = false;

  /// The active index of refraction.
  float ior = 1 / 1.4;

  /// The active normal direction.
  float3 normal = float3(0, 0, 1);

  /// The active tangent direction.
  float3 tangent_u = float3(1, 0, 0);

  /// The active outgoing direction (expanded in the active tangent space).
  float3 wo = wo0;

  /// The canonical random sample in [0,1]^4. 
  float4 xi;

  finalize {
    // If we hit the backface, flip everything so that `wo` 
    // is always in the upper hemisphere.
    if (hit_backface) {
      wo0 = -wo0;
      wo = -wo;
      ior = 1 / ior;
    }
  }
};

struct scatter_sample_result {
  /// The sampled incoming direction.
  float3 wi = float3(0.0);

  /// The sampled scatter mode.
  scatter_mode mode = scatter_none;

  /// If sampled from a directional delta distribution, the BSDF evaluation (which is otherwise unevaluable).
  ?color delta_f = void();
};

@(pure noinline) ?float3x3 recalculate_tangent_space(inline const &scatter_sample_parameters params) {
  auto tbn(build_tangent_space(normal, tangent_u));
  wo = wo0 * tbn;
  return tbn if ((wo.z < 0) == (wo0.z < 0));
}

@(pure) float3 half_direction(inline const &scatter_sample_parameters this, inline const &scatter_sample_result result) {
  return normalize(mode == scatter_reflect ? wo + wi : specular::refraction_half_vector(wo, wi, ior));
}

//--{ default_bsdf
@(pure macro) auto scatter_evaluate(const &$default_bsdf this, const &scatter_evaluate_parameters params) {
  return scatter_evaluate_result(is_black: true);
}

@(pure macro) auto scatter_sample(const &$default_bsdf this, const &scatter_sample_parameters params) {
  return scatter_sample_result();
}
//--}

//--{ diffuse_reflection_bsdf
export struct diffuse_reflection_bsdf: bsdf {
  /// The tint.
  $(color | float) tint = 1.0;

  /// The roughness.
  float roughness = 0.0;

  /// The handle.
  string handle = "";
};

@(pure) auto scatter_evaluate(inline const &diffuse_reflection_bsdf this, inline const &scatter_evaluate_parameters params) {
  if (mode == scatter_reflect && recalculate_tangent_space(params)) {
    const auto cos_theta(#abs(auto(wi.z, wo.z)));
    const auto pdf(cos_theta / $PI);
    if (roughness == 0) {
      return scatter_evaluate_result(f: pdf[0] * tint, pdf: pdf);
    } else {
      // Oren-Nayar terms.
      const auto sigma2(2.0 * roughness * roughness);
      const auto A(1.00 - sigma2 / (2.0 * sigma2 + 0.66));
      const auto B(0.45 * sigma2 / (sigma2 + 0.09));
      const auto fac(#max(#sum(wo.xy * wi.xy), 0) / #max_value(cos_theta));
      return scatter_evaluate_result(f: pdf[0] * (A + fac * B) * tint, pdf: pdf);
    }
  } else {
    return scatter_evaluate_result(is_black: true);
  }
}

@(pure) auto scatter_sample(inline const &diffuse_reflection_bsdf this, inline const &scatter_sample_parameters params) {
  if ((tbn := recalculate_tangent_space(params))) {
    return scatter_sample_result(wi: (*tbn) * monte_carlo::cosine_hemisphere_sample(xi.xy), mode: scatter_reflect);
  } else {
    return scatter_sample_result(); // Reject
  }
}
//--}

//--{ diffuse_transmission_bsdf
export struct diffuse_transmission_bsdf: bsdf {
  /// The tint.
  $(color | float) tint = 1.0;

  /// The handle.
  string handle = "";
};

@(pure) auto scatter_evaluate(inline const &diffuse_transmission_bsdf this, inline const &scatter_evaluate_parameters params) {
  if (mode == scatter_transmit && recalculate_tangent_space(params)) {
    const auto cos_theta(#abs(auto(wi.z, wo.z)));
    const auto pdf(cos_theta / $PI);
    return scatter_evaluate_result(f: tint * pdf[0], pdf: pdf);
  } else {
    return scatter_evaluate_result(is_black: true);
  }
}

@(pure) auto scatter_sample(inline const &diffuse_transmission_bsdf this, inline const &scatter_sample_parameters params) {
  if ((tbn := recalculate_tangent_space(params))) {
    return scatter_sample_result(wi: (*tbn) * -monte_carlo::cosine_hemisphere_sample(xi.xy), mode: scatter_transmit);
  } else {
    return scatter_sample_result(); // Reject
  }
}
//--}

//--{ sheen_bsdf
export struct sheen_bsdf: bsdf {
  /// The roughness.
  float roughness;

  /// The tint.
  $(color | float) tint = 1.0;

  /// The multiscatter tint.
  $(color | float | void) multiscatter_tint = void();

  /// The multiscatter lobe. Unused, but I think this part of the later MDL spec?
  void multiscatter = void();

  /// The handle.
  string handle = "";

  finalize {
    roughness = saturate(roughness);
  }
};

@(pure) float sheen_lambda_l(const auto fit, const float mu) {
  return fit[0] / (1.0 + fit[1] * #pow(mu, fit[2])) + fit[3] * mu + fit[4];
}

@(pure) float sheen_lambda(const auto fit, const float mu) {
  return #exp(mu < 0.5 ? sheen_lambda_l(fit, mu) : 2 * sheen_lambda_l(fit, 0.5) - sheen_lambda_l(fit, #max(1 - mu, 0)));
}

@(pure) auto scatter_evaluate(inline const &sheen_bsdf this, inline const &scatter_evaluate_parameters params) {
  if (mode == scatter_reflect && recalculate_tangent_space(params)) {
    const auto cos_thetao(#abs(wo.z));
    const auto cos_thetai(#abs(wi.z));
    const auto pdf(float2(cos_thetai, cos_thetao) / $PI);
    const auto fss = let {
      const auto alpha(lerp(0.1, 1.0, roughness * roughness));
      const auto fit = lerp(
        auto(21.5473, 3.82987, 0.19823, -1.97760, -4.32054),
        auto(25.3245, 3.32435, 0.16801, -1.27393, -4.85967),
        (1 - alpha) * (1 - alpha),
      );
      const auto cos_thetah(normalize(wo + wi).z);
      const auto sin_thetah(#sqrt(1 - cos_thetah * cos_thetah + SCATTER_EPS));
      const auto D(1 / $TWO_PI * (2 + 1 / alpha) * #pow(sin_thetah, 1 / alpha));
      const auto G(1 / (1 + sheen_lambda(fit, cos_thetao) + sheen_lambda(fit, cos_thetai)));
    } in D * G / (4 * cos_thetao + SCATTER_EPS);
    return scatter_evaluate_result(f: tint * fss, pdf: pdf);
  } else {
    return scatter_evaluate_result(is_black: true);
  }
}

@(pure) auto scatter_sample(inline const &sheen_bsdf this, inline const &scatter_sample_parameters params) {
  if ((tbn := recalculate_tangent_space(params))) {
    return scatter_sample_result(wi: (*tbn) * monte_carlo::cosine_hemisphere_sample(xi.xy), mode: scatter_reflect);
  } else {
    return scatter_sample_result(); // Reject
  }
}
//--}

//--{ ward_geisler_moroder_bsdf 
export struct ward_geisler_moroder_bsdf: bsdf {
  /// The roughness in U.
  float roughness_u;

  /// The roughness in V.
  float roughness_v = roughness_u;

  /// The tint.
  $(color | float) tint = 1.0;

  /// The multiscatter tint, or `void` for no multiscatter.
  $(color | float | void) multiscatter_tint = void();

  /// The tangent in U.
  float3 tangent_u = $state.texture_tangent_u[0];

  /// The handle.
  string handle = "";

  finalize {
    roughness_u = saturate(roughness_u);
    roughness_v = saturate(roughness_v);
  }
};

@(pure noinline) auto scatter_evaluate(const &ward_geisler_moroder_bsdf this, inline const &scatter_evaluate_parameters params) {
  preserve tangent_u;
  tangent_u = this.tangent_u;
  if (mode == scatter_reflect && recalculate_tangent_space(params)) {
    const auto cos_thetao(#abs(wo.z));
    const auto cos_thetai(#abs(wi.z));
    const auto roughness(this.roughness_u, this.roughness_v);
    const auto alpha(#max(0.001, roughness * roughness));
    const auto f(#sum((h := wo + wi) * h) / ($PI * alpha.x * alpha.y * #pow(h.z, 4)) * #exp(-#sum((g := h.xy / (h.z * alpha)) * g)));
    // Single-scattering.
    const auto fss_pdf(float2(f * (cos_thetao + cos_thetai) / 2));
    const auto fss(f * cos_thetai);
    if $(#typeof(this.multiscatter_tint) == void) {
      return scatter_evaluate_result(f: this.tint * fss, pdf: fss_pdf);
    } else {
      // Multiple-scattering.
      const auto fms_pdf(float2(cos_thetai, cos_thetao) / $PI);
      const auto fms = let {
        const auto r0(#sqrt(roughness.x * roughness.y));
        const auto fit = return_from {
          // Parallel evaluation of 3 different 8th-order polynomials
          // fit[0] = 1st coefficient in directional albedo fit
          // fit[1] = 2nd coefficient in directional albedo fit
          // fit[2] = Average albedo
          float3 fit(-1.1992005e+02, -1.4040313e+01, +7.8306640e-01);
          fit = fit * r0 + float3(+4.1985368e+02, +4.6807753e+01, -1.6213743e+00);
          fit = fit * r0 + float3(-5.8448171e+02, -6.1370147e+01, -1.3797964e+00);
          fit = fit * r0 + float3(+4.2351783e+02, +4.1399258e+01, +5.6539624e+00);
          fit = fit * r0 + float3(-1.6959530e+02, -1.4979874e+01, -3.8064856e+00);
          fit = fit * r0 + float3(+3.7025769e+01, +3.0665596e+00, -1.2666234e-01);
          fit = fit * r0 + float3(-3.4191809e+00, -2.9108604e-01, -1.8175253e-02);
          fit = fit * r0 + float3(+1.6044891e-01, +8.8001559e-03, +1.4868175e-03);
          fit = fit * r0 + float3(-7.1467185e-04, +1.8095055e-01, +9.9998607e-01);
          return fit;
        };
        const auto Ewo(#min(1 - fit[1] * (t := #pow(cos_thetao / fit[0], 2.0 / 3.0)) * #exp(1 - t), 0.999));
        const auto Ewi(#min(1 - fit[1] * (t := #pow(cos_thetai / fit[0], 2.0 / 3.0)) * #exp(1 - t), 0.999));
        const auto Eav(#min(fit[2], 0.999));
      } in (1 - Ewo) * (1 - Ewi) / (1 - Eav) * cos_thetai / $PI;
      return scatter_evaluate_result(f: this.tint * (fss + this.multiscatter_tint * fms), pdf: lerp(fss_pdf, fms_pdf, MULTISCATTER_DIFFUSE_CHANCE));
    }
  } else {
    return scatter_evaluate_result(is_black: true);
  }
}

@(pure noinline) auto scatter_sample(const &ward_geisler_moroder_bsdf this, inline const &scatter_sample_parameters params) {
  preserve tangent_u;
  tangent_u = this.tangent_u;
  if ((tbn := recalculate_tangent_space(params))) {
    // Sample diffuse (20% chance if multiscattering)
    if (#typeof(this.multiscatter_tint) != void && monte_carlo::bool_sample(&xi.w, MULTISCATTER_DIFFUSE_CHANCE)) {
      return scatter_sample_result(wi: (*tbn) * monte_carlo::cosine_hemisphere_sample(xi.xy), mode: scatter_reflect);
    }
    // Sample specular.
    const auto roughness(this.roughness_u, this.roughness_v);
    const auto alpha(#max(0.001, roughness * roughness));
    const auto phi(#atan2(alpha.y * #sin(t := $TWO_PI * xi.x), alpha.x * #cos(t)));
    const auto cos_phi(#cos(phi));
    const auto sin_phi(#sin(phi));
    const auto theta(#atan(#sqrt(-#log(1 - xi.y) / (#pow(cos_phi / alpha.x, 2) + #pow(sin_phi / alpha.y, 2)))));
    const auto wm(float3(#sin(theta) * float2(cos_phi, sin_phi), #cos(theta)));
    const auto wi(normalize(specular::reflect(wo, wm)));
    if (wi.z > 0) {
      return scatter_sample_result(wi: (*tbn) * wi, mode: scatter_reflect);
    }
  }
  return scatter_sample_result();
}
//--}

//--{ microfacet
export namespace microfacet {

export tag distribution;

export struct distribution_ggx: default distribution {};

export struct distribution_beckmann: distribution {};

export struct distribution_blinn: distribution {};

export @(pure macro) float smith_lambda(const distribution_ggx this [[anno::unused()]],
                                        const float m) {
  return 0.5 * (#sign(m) * #sqrt(1 + 1 / (m * m + SCATTER_EPS))) - 0.5;
}

export @(pure macro) float smith_lambda(const distribution_beckmann this [[anno::unused()]],
                                        const float m) {
  return 0.5 * (#exp(-m * m) / m / #sqrt($PI) - erfcf(m));
}

export @(pure macro) float smith_slope_pdf(const distribution_ggx this [[anno::unused()]],
                                           const float2 m) {
  return (1 / $PI) / #pow(1 + #sum(m * m), 2);
}

export @(pure macro) float smith_slope_pdf(const distribution_beckmann this [[anno::unused()]],
                                           const float2 m) {
  return (1 / $PI) * #exp(-#sum(m * m));
}

export @(pure macro) float smith_normal_pdf(const distribution this [[anno::unused()]],
                                            const float2 alpha, const float3 wm) {
  return wm.z > 0.0 ? smith_slope_pdf(this, -wm.xy / (wm.z * alpha + SCATTER_EPS)) / (alpha.x * alpha.y * #pow(wm.z, 4) + SCATTER_EPS) : 0.0;
}

export @(pure noinline) float2 smith_visible_slope_sample(
  const distribution_ggx this,
  const float xi0,
  const float xi1,
  float cos_thetao,
) {
  return #sqrt(xi0 / (1 - xi0 + SCATTER_EPS)) * float2(#cos(phi := $TWO_PI * xi1), #sin(phi)) if (cos_thetao > +0.9999);
  cos_thetao = #max(cos_thetao, -0.9999);
  const auto mx = return_from {
    const auto sin_thetao(#sqrt(1 - cos_thetao * cos_thetao));
    const auto tan_thetao(sin_thetao / cos_thetao);
    const auto mu(xi0 * (1 + 1 / cos_thetao) - 1);
    const auto nu(1 / (1 - mu * mu));
    const auto d(#sqrt(#max(nu * (mu * mu - (1 - nu) * tan_thetao * tan_thetao), 0)));
    const auto mx0(-nu * tan_thetao - d);
    const auto mx1(-nu * tan_thetao + d);
    return #select((mu < 0) | (mx1 * sin_thetao > cos_thetao), mx0, mx1);
  };
  const auto my = return_from {
    const auto s(#select(xi1 > 0.5, +1.0, -1.0));
    const auto t(#min(s * (2 * xi1 - 1), 1));
    return #sqrt(1 + mx * mx) * s * ((t * (t * (t * 0.273850 - 0.733690) + 0.463410)) / (t * (t * (t * 0.093073 + 0.309420) - 1.000000) + 0.597999));
  };
  return float2(mx, my);
}

export @(pure noinline) float3 smith_visible_normal_sample(
  const distribution this,
  const float xi0,
  const float xi1,
  const float2 alpha,
  const float3 wo,
) {
  const auto w11(normalize(float3(alpha * wo.xy, wo.z)));
  const auto sin_theta(length(w11.xy));
  const auto cos_phi(w11.x / sin_theta);
  const auto sin_phi(w11.y / sin_theta);
  const auto m11(smith_visible_slope_sample(this, xi0, xi1, w11.z));
  const auto m(float2(alpha.x * dot(float2(cos_phi, -sin_phi), m11), //
                      alpha.y * dot(float2(sin_phi, +cos_phi), m11)));
  return #all(isfinite(m)) ? normalize(float3(m, 1)) : wo.z == 0 ? normalize(wo) : float3(0, 0, 1);
}

export @(pure macro) void blinn_normal_first_quadrant_sample(
  const float xi0,
  const float xi1,
  const float2 e,
  &float phi,
  &float cos_theta,
) {
  if (e.x == e.y) {
    *phi = $HALF_PI * xi0;
    *cos_theta = #pow(xi1, 1 / (1 + e.x));
  } else {
    *phi = #atan(#sqrt((1 + e.x) / (1 + e.y)) * #tan($HALF_PI * xi0));
    *cos_theta = #pow(xi1, 1 / (1 + e.x * (cos_phi := #cos(*phi)) * cos_phi + e.y * (sin_phi := #sin(*phi)) * sin_phi));
  }
}

export @(pure noinline) float3 blinn_normal_sample(const float xi0, const float xi1, const float2 e) {
  float phi = 0;
  float cos_theta = 0;
  if (xi0 < 0.25) {
    blinn_normal_first_quadrant_sample(4 * xi0, xi1, e, &phi, &cos_theta);
  } else if (xi0 < 0.5) {
    blinn_normal_first_quadrant_sample(4 * (0.5 - xi0), xi1, e, &phi, &cos_theta), phi = $PI - phi;
  } else if (xi0 < 0.75) {
    blinn_normal_first_quadrant_sample(4 * (xi0 - 0.5), xi1, e, &phi, &cos_theta), phi += $PI;
  } else {
    blinn_normal_first_quadrant_sample(4 * (1 - xi0), xi1, e, &phi, &cos_theta), phi = $TWO_PI - phi;
  }
  return float3(#sqrt(1 - cos_theta * cos_theta + SCATTER_EPS) * float2(#cos(phi), #sin(phi)), cos_theta);
}

export tag shadowing;

export struct shadowing_smith: default shadowing {};

export struct shadowing_vcavities: shadowing {};

export @(pure) float beta(const float x, const float y) = #exp(#lgamma(x) + #lgamma(y) - #lgamma(x + y));

} // namespace microfacet

struct microfacet_bsdf: bsdf {
  float2 roughness;

  float2 alpha = roughness * roughness;

  float roughness0 = #sqrt(#prod(roughness));

  $(color | float) tint;

  $(color | float | void) multiscatter_tint = void();

  float3 tangent_u = state::texture_tangent_u(0);

  scatter_mode mode = scatter_reflect;

  const microfacet::distribution distribution = microfacet::distribution();

  const microfacet::shadowing shadowing = microfacet::shadowing();

  finalize {
    alpha = #max(alpha, 0.00001);
    alpha = #min(alpha, 1.0);
    tangent_u = normalize(tangent_u);
  }
};

@(pure noinline) auto scatter_evaluate(const &microfacet_bsdf this, inline const &scatter_evaluate_parameters params) {
  preserve tangent_u;
  tangent_u = this.tangent_u;
  return scatter_evaluate_result(is_black: true) if (!recalculate_tangent_space(params));
  const auto reflect_chance(scatter_reflect_chance(this.mode));
  const auto wm(normalize(mode == scatter_reflect ? wo + wi : specular::refraction_half_vector(wo, wi, ior)));
  const auto dot_wo_wm(#sum(wo * wm));
  const auto dot_wi_wm(#sum(wi * wm));
  if $(this.distribution <: microfacet::distribution_blinn) {
    const auto e(2 / (this.alpha * this.alpha + SCATTER_EPS));
    const auto d(#pow(wm.z, (e.x * wm.x * wm.x + e.y * wm.y * wm.y) / (1 - wm.z * wm.z + SCATTER_EPS)) / $TWO_PI);
    const auto norm1(#sqrt(#prod(1 + e)));
    const auto norm2(#sqrt(#prod(2 + e)));
    const auto g(#min(1, 2 * wm.z * #min(#abs(wo.z / (dot_wo_wm + SCATTER_EPS)), //
                                         #abs(wi.z / (dot_wi_wm + SCATTER_EPS)))));
    switch (int(mode) & int(this.mode)) {
    case int(scatter_reflect): {
      const auto fss_pdf(norm1 * d / (4 * float2(dot_wo_wm, dot_wi_wm) + SCATTER_EPS));
      const auto fss(norm2 * d * g / (4 * #abs(wo.z) + SCATTER_EPS));
      if $(this.multiscatter_tint <: void) {
        return scatter_evaluate_result(pdf: reflect_chance * fss_pdf, f: this.tint * (reflect_chance * fss));
      } else {
        const auto r0(this.roughness0);
        const auto fms_pdf(#abs(wi.z) / $PI);
        const auto fms = return_from {
          // TODO Blinn fit
          return 0.0;
        };
        return scatter_evaluate_result(pdf: reflect_chance * lerp(fss_pdf, fms_pdf, MULTISCATTER_DIFFUSE_CHANCE), f: reflect_chance * this.tint * (fss + this.multiscatter_tint * fms));
      }
    }
    case int(scatter_transmit): {
      return scatter_evaluate_result(is_black: true) if (!((dot_wo_wm > 0) & (dot_wi_wm < 0)));
      // TODO
    }
    default: break;
    }
  } else {
    const auto d(microfacet::smith_normal_pdf(this.distribution, this.alpha, wm));
    const auto lambdao(microfacet::smith_lambda(this.distribution, #abs(wo.z) / (length(this.alpha * wo.xy) + SCATTER_EPS)));
    const auto lambdai(microfacet::smith_lambda(this.distribution, #abs(wi.z) / (length(this.alpha * wi.xy) + SCATTER_EPS)));
    const auto proj_areao((1 + lambdao) * #abs(wo.z));
    const auto proj_areai((1 + lambdai) * #abs(wi.z));
    const auto g = return_from {
      if $(this.shadowing <: microfacet::shadowing_smith) {
        return mode == scatter_reflect ? 1 / (1 + lambdao + lambdai) : microfacet::beta(1 + lambdao, 1 + lambdai);
      } else {
        // V-cavities
        return #min(1, 2 * wm.z * #min(#abs(wo.z / (dot_wo_wm + SCATTER_EPS)), //
                                       #abs(wi.z / (dot_wi_wm + SCATTER_EPS))));
      }
    };
    switch (int(mode) & int(this.mode)) {
    case int(scatter_reflect): {
      const auto fss_pdf(d / (4 * float2(proj_areao, proj_areai) + SCATTER_EPS));
      const auto fss(d * g / (4 * #abs(wo.z) + SCATTER_EPS));
      if $(this.multiscatter_tint <: void) {
        return scatter_evaluate_result(pdf: reflect_chance * fss_pdf, f: this.tint * (reflect_chance * fss));
      } else {
        const auto r0(this.roughness0);
        const auto fms_pdf(#abs(wi.z) / $PI);
        const auto fms = return_from {
          if (this.distribution <: microfacet::distribution_ggx) {
            const auto fit = return_from {
              auto fit(float3(0.0));
              if (r0 < 0.06299) {
                fit = float3(29.2553519, 0.3728114, 0.1845677);
              } else if (r0 < 0.1259843) {
                fit = float3(-6.2876897e+07, -4.9194766e+06, 3.3173219e+06);
                fit = fit * r0 + float3(+3.4025124e+07, +2.4576227e+06, -1.6123845e+06);
                fit = fit * r0 + float3(-7.2367180e+06, -4.8558372e+05, +3.0882525e+05);
                fit = fit * r0 + float3(+7.5011789e+05, +4.7293248e+04, -2.9071452e+04);
                fit = fit * r0 + float3(-3.7635419e+04, -2.2570320e+03, +1.3407965e+03);
                fit = fit * r0 + float3(+7.5899155e+02, +4.2444028e+01, -2.4013229e+01);
              } else if (r0 < 0.503970) {
                fit = float3(-4.2253228e+03, +1.6913746e+02, -7.8179263e+00);
                fit = fit * r0 + float3(+9.6952817e+03, -3.5406749e+02, +1.1760316e+01);
                fit = fit * r0 + float3(-8.8256161e+03, +2.7638671e+02, -5.2975185e+00);
                fit = fit * r0 + float3(+4.0337334e+03, -9.8577485e+01, +1.2001528e+00);
                fit = fit * r0 + float3(-9.5198727e+02, +1.5754557e+01, -1.4087179e-01);
                fit = fit * r0 + float3(+1.0006441e+02, -1.4926819e-01, +1.1518670e-01);
              } else {
                fit = float3(-5.9786880e+01, -5.8887035e+01, 4.1460911e+02);
                fit = fit * r0 + float3(+2.2101716e+02, +2.1996966e+02, -1.3466323e+03);
                fit = fit * r0 + float3(-3.3692861e+02, -3.1412912e+02, +1.7465495e+03);
                fit = fit * r0 + float3(+2.8006161e+02, +2.1178043e+02, -1.1260412e+03);
                fit = fit * r0 + float3(-1.3115488e+02, -6.7437900e+01, +3.6066098e+02);
                fit = fit * r0 + float3(+2.8927807e+01, +8.9207463e+00, -4.5752769e+01);
              }
              fit.z *= #pow(2.71828182459 * fit.x * fit.y, 1.0 / fit.y);
              return fit;
            };
            // RMSE = 0.0031914257273857496
            const auto Ewo(#min(#exp(-fit[2] * #abs(wo.z) * #exp(-fit[0] * #pow(#abs(wo.z), fit[1]))), 0.999));
            const auto Ewi(#min(#exp(-fit[2] * #abs(wi.z) * #exp(-fit[0] * #pow(#abs(wi.z), fit[1]))), 0.999));
            const auto Eav = return_from {
              float fit = -0.40461439;
              fit = fit * r0 + 2.33942628;
              fit = fit * r0 - 3.15953698;
              fit = fit * r0 + 0.69762445;
              fit = fit * r0 - 0.06449884;
              fit = fit * r0 + 1.00125673;
              return #min(fit, 0.999);
            };
            return (1 - Ewo) * (1 - Ewi) / (1 - Eav) * #abs(wi.z) / $PI;
          } else {
            // TODO Beckmann fit
            return 0;
          }
        };
        return scatter_evaluate_result(pdf: reflect_chance * lerp(fss_pdf, fms_pdf, MULTISCATTER_DIFFUSE_CHANCE), f: reflect_chance * this.tint * (fss + this.multiscatter_tint * fms));
      }
    }
    case int(scatter_transmit): {
      return scatter_evaluate_result(is_black: true) if (!((dot_wo_wm > 0) & (dot_wi_wm < 0)));
      const auto j(float2(specular::refraction_half_vector_jacobian(wo, wi, ior), //
                          specular::refraction_half_vector_jacobian(wi, wo, 1 / ior)));
      const auto fss_pdf(d * j * float2(dot_wo_wm, -dot_wi_wm) / (float2(proj_areao, proj_areai) + SCATTER_EPS));
      const auto fss(d * g * j[0] * dot_wo_wm / (#abs(wo.z) + SCATTER_EPS));
      return scatter_evaluate_result(pdf: (1 - reflect_chance) * fss_pdf, f: this.tint * ((1 - reflect_chance) * fss));
    }
    default: break;
    }
  }
  return scatter_evaluate_result(is_black: true);
}

@(pure noinline) auto scatter_sample(const &microfacet_bsdf this, inline const &scatter_sample_parameters params) {
  preserve tangent_u;
  tangent_u = this.tangent_u;
  auto tbn(recalculate_tangent_space(params));
  if (!tbn)
    return scatter_sample_result();
  // Decide whether to reflect or transmit. Note: This is not Fresnel-weighted. It is
  // either deterministic or 50/50.
  // - If `this.mode == scatter_reflect`, 100% chance to reflect.
  // - If `this.mode == scatter_transmit`, 100% chance to transmit.
  // - If `this.mode == scatter_reflect_transmit`, 50% chance to reflect and 50% chance to transmit.
  const auto mode(monte_carlo::bool_sample(&xi.z, scatter_reflect_chance(this.mode)) ? scatter_reflect : scatter_transmit);
  // If `multiscatter_tint` is present and we decided to reflect, sample a diffuse lobe occasionally.
  if (!(this.multiscatter_tint <: void) && mode == scatter_reflect && monte_carlo::bool_sample(&xi.w, MULTISCATTER_DIFFUSE_CHANCE)) {
    return scatter_sample_result(wi: (*tbn) * monte_carlo::cosine_hemisphere_sample(xi.xy), mode: scatter_reflect);
  }
  // Otherwise, sample a microsurface normal direction from the distribution, then either reflect or
  // refract through the normal depending on whether we decided to reflect or transmit. Note: The Blinn 
  // distribution is not a closed-form scale-invariant Smith distribution, so it has a separate normal 
  // sampling routine.
  const auto wm = return_from {
    if $(this.distribution <: microfacet::distribution_blinn) {
      return microfacet::blinn_normal_sample(xi.x, xi.y, 2 / (this.alpha * this.alpha + SCATTER_EPS));
    } else {
      return microfacet::smith_visible_normal_sample(this.distribution, xi.x, xi.y, this.alpha, wo);
    }
  };
  const auto wi = normalize(mode == scatter_reflect     //
                            ? specular::reflect(wo, wm) //
                            : specular::refract(wo, wm, ior));
  return scatter_sample_result(wi: (*tbn) * wi, mode: mode);
}

@(macro) auto initialize_microfacet_bsdf(
  const float roughness_u,
  const float roughness_v = roughness_u,
  const $(color | float) tint = 1.0,
  const $(color | float | void) multiscatter_tint = $nothing,
  const float3 tangent_u = $state.texture_tangent_u[0],
  const scatter_mode mode = scatter_reflect,
  const string handle = "" [[anno::unused()]],
  const microfacet::distribution distribution = microfacet::distribution(),
  const microfacet::shadowing shadowing = microfacet::shadowing(),
) {
  // if ((roughness_u > 0) | (roughness_v > 0)) {
  return microfacet_bsdf(
    roughness: float2(roughness_u, roughness_v),
    tint: tint,
    multiscatter_tint: multiscatter_tint,
    tangent_u: tangent_u,
    mode: mode,
    distribution: distribution,
    shadowing: shadowing,
  );
  // } else {
  //   return specular_bsdf(tint: tint, mode: mode);
  // }
}
//--}

export auto simple_glossy_bsdf(*) = initialize_microfacet_bsdf(distribution: microfacet::distribution_blinn(), shadowing: microfacet::shadowing_vcavities());

export auto microfacet_ggx_smith_bsdf(*) = initialize_microfacet_bsdf(distribution: microfacet::distribution_ggx(), shadowing: microfacet::shadowing_smith());

export auto microfacet_ggx_vcavities_bsdf(*) = initialize_microfacet_bsdf(distribution: microfacet::distribution_ggx(), shadowing: microfacet::shadowing_vcavities());

export auto microfacet_beckmann_smith_bsdf(*) = initialize_microfacet_bsdf(distribution: microfacet::distribution_beckmann(), shadowing: microfacet::shadowing_smith());

export auto microfacet_beckmann_vcavities_bsdf(*) = initialize_microfacet_bsdf(distribution: microfacet::distribution_beckmann(), shadowing: microfacet::shadowing_vcavities());

//--{ tint
/// A 1-value tint.
struct tint1: bsdf, edf, hair_bsdf {
  /// The tint multiplier.
  $(color | float) tint;

  /// The base `bsdf`, `edf`, or `hair_bsdf`.
  auto base;
};

/// A 2-value tint.
struct tint2: bsdf {
  /// The tint multiplier on reflection.
  $(color | float) reflection_tint;

  /// The tint multiplier on transmission.
  $(color | float) transmission_tint;

  /// The base `bsdf`.
  bsdf base;
};

/// Construct 1-value tint of the given `bsdf`.
export @(pure macro) auto tint(const auto tint, const bsdf base) = tint1(tint, base);

/// Construct 1-value tint of the given `edf`.
export @(pure macro) auto tint(const auto tint, const edf base) = tint1(tint, base);

/// Construct 1-value tint of the given `hair_bsdf`.
export @(pure macro) auto tint(const auto tint, const hair_bsdf base) = tint1(tint, base);

/// Construct 2-value tint of the given `bsdf`.
export @(pure macro) auto tint(const auto reflection_tint, const auto transmission_tint, const bsdf base) = tint2(reflection_tint, transmission_tint, base);

@(pure macro) auto scatter_evaluate(const &tint1 this, const &scatter_evaluate_parameters params) {
  auto result(scatter_evaluate(visit &this.base, params));
  if (!result.is_black)
    result.f *= this.tint;
  return result;
}

@(pure macro) auto scatter_evaluate(const &tint2 this, const &scatter_evaluate_parameters params) {
  auto result(scatter_evaluate(visit &this.base, params));
  if (!result.is_black) {
    if (params.mode == scatter_reflect) {
      result.f *= this.reflection_tint;
    } else {
      result.f *= this.transmission_tint;
    }
  }
  return result;
}

@(pure macro) auto scatter_sample(const &tint1 this, const &scatter_sample_parameters params) {
  auto result(scatter_sample(visit &this.base, params));
  if ((result.mode != scatter_none) & bool(result.delta_f))
    *result.delta_f *= this.tint;
  return result;
}

@(pure macro) auto scatter_sample(const &tint2 this, const &scatter_sample_parameters params) {
  auto result(scatter_sample(visit &this.base, params));
  if ((result.mode != scatter_none) & bool(result.delta_f)) {
    if (params.mode == scatter_reflect) {
      *result.delta_f *= this.reflection_tint;
    } else {
      *result.delta_f *= this.transmission_tint;
    }
  }
  return result;
}
//--}

//--{ weighted_layer, color_weighted_layer
export struct weighted_layer: bsdf {
  /// The weight. 
  $(color | float) weight;

  /// The layer BSDF.
  bsdf layer = bsdf();

  /// The base BSDF.
  bsdf base = bsdf();

  /// The normal to use for the layer.
  float3 normal = $state.normal;

  /// The chance of sampling the layer BSDF.
  ///
  /// \note
  /// If the weight is a `float`, then the chance is the same
  /// as the weight. However, if the weight is a `color`, we
  /// have to average it down to a single probability.
  ///
  float chance = average(weight);

  finalize {
    weight = saturate(weight);
    chance = saturate(chance);
  }
};

@(pure macro) auto scatter_evaluate(const &weighted_layer this, inline const &scatter_evaluate_parameters params) {
  auto result0(scatter_evaluate(visit &this.base, params));
  preserve normal;
  normal = this.normal;
  auto result1(scatter_evaluate(visit &this.layer, params));
  return scatter_evaluate_result(f: lerp(result0.f, result1.f, this.weight), pdf: lerp(result0.pdf, result1.pdf, this.chance), is_black: result0.is_black & result1.is_black);
}

@(pure macro) auto scatter_sample(const &weighted_layer this, inline const &scatter_sample_parameters params) {
  if (monte_carlo::bool_sample(&xi.w, this.chance)) {
    preserve normal;
    normal = this.normal;
    return scatter_sample(visit &this.layer, params);
  } else {
    return scatter_sample(visit &this.base, params);
  }
}

/// The `color_weighted_layer` is also implemented by the `weighted_layer`.
export typedef weighted_layer color_weighted_layer;
//--}

//--{ fresnel_layer, color_fresnel_layer
export struct fresnel_layer: bsdf {
  /// The index of refraction.
  $(color | float) ior;

  $(color | float) weight = 1.0;

  bsdf layer = bsdf();

  bsdf base = bsdf();

  float3 normal = $state.normal;

  /// Precompute the average index of refraction.
  const float av_ior = average(ior);

  /// Precompute the average weight.
  const float av_weight = average(weight);
};

@(pure macro) auto scatter_evaluate(const &fresnel_layer this, inline const &scatter_evaluate_parameters params) {
  const auto cos_thetao(dot(wo, this.normal) * #sign(this.normal.z));
  const auto cos_thetai(dot(wi, this.normal) * #sign(this.normal.z));
  if ((cos_thetao < SCATTER_EPS)                                 //
      | ((mode == scatter_reflect) & (cos_thetai < SCATTER_EPS)) //
      | ((mode == scatter_transmit) & (cos_thetai > -SCATTER_EPS)))
    return scatter_evaluate_result(is_black: true);
  const auto result0(scatter_evaluate(visit &this.base, params));
  const auto result1 = return_from {
    preserve normal, ior;
    normal = this.normal, ior = 1 / this.av_ior; // Assume IOR of 1.4 => relative IOR of 1 / 1.4
    return scatter_evaluate(visit &this.layer, params);
  };
  if (result0.is_black & result1.is_black) {
    return scatter_evaluate_result(is_black: true);
  } else {
    return scatter_evaluate_result(
      pdf: lerp(result0.pdf, result1.pdf, this.av_weight * specular::schlick_fresnel(float2(cos_thetao, cos_thetai), specular::schlick_F0(this.av_ior))),
      f: lerp(result0.f, result1.f, this.weight * specular::dielectric_fresnel(dot(wo, half_direction(params)), 1 / this.ior)),
    );
  }
}

@(pure macro) auto scatter_sample(const &fresnel_layer this, inline const &scatter_sample_parameters params) {
  const auto cos_theta(dot(wo, this.normal) * #sign(this.normal.z));
  if (cos_theta < SCATTER_EPS)
    return scatter_sample_result();
  const auto chance(this.av_weight * specular::schlick_fresnel(cos_theta, specular::schlick_F0(this.av_ior)));
  if (monte_carlo::bool_sample(&xi.z, chance)) {
    preserve normal, ior;
    normal = this.normal, ior = 1 / this.av_ior; // Assume IOR of 1.4 => relative IOR of 1/1.4
    auto result(scatter_sample(visit &this.layer, params));
    if (result.delta_f)
      *result.delta_f *= this.weight * specular::dielectric_fresnel(dot(wo, half_direction(params, &result)), 1 / this.ior) / chance;
    return result;
  } else {
    auto result(scatter_sample(visit &this.base, params));
    if (result.delta_f)
      *result.delta_f *= (1 - this.weight * specular::dielectric_fresnel(dot(wo, half_direction(params, &result)), 1 / this.ior)) / (1 - chance);
    return result;
  }
}

export typedef fresnel_layer color_fresnel_layer;
//--}

export @(pure macro) int $scatter_evaluate(
  const &$material_instance instance,
  const &float3 wo,     ///< \param[in] The outgoing direction
  const &float3 wi,     ///< \param[in] The incoming direction
  const &float pdf_fwd, ///< \param[out] The PDF of sampling `wi` from `wo`
  const &float pdf_rev, ///< \param[out] The PDF of sampling `wo` from `wi`
  const &float f,       ///< \param[out] The scattering function
) {
  auto params = scatter_evaluate_parameters(
    wo0: normalize(*wo), // Guarantee normalized
    wi0: normalize(*wi), // Guarantee normalized
    thin_walled: instance.mat.thin_walled,
    normal: normalize(*instance.normal),
  );
  auto result = #typeof(instance.mat.backface) == #typeof(material_surface()) || !params.hit_backface //
                ? scatter_evaluate(&instance.mat.surface.scattering, &params)                         //
                : scatter_evaluate(&instance.mat.backface.scattering, &params);
  visit result in result {
    if (result.is_black) {
      *pdf_fwd = 0;
      *pdf_rev = 0;
      for (int i = 0; i < $WAVELENGTH_BASE_MAX; i++)
        f[i] = 0.0;
    } else {
      *pdf_fwd = result.pdf[0];
      *pdf_rev = result.pdf[1];
      if (#typeof(result.f) == float) {
        for (int i = 0; i < $WAVELENGTH_BASE_MAX; i++)
          f[i] = result.f;
      } else {
        #memcpy(f, &result.f, #sizeof(float) * $WAVELENGTH_BASE_MAX);
      }
    }
    return !result.is_black;
  }
}

export @(pure macro) int $scatter_sample(
  const &$material_instance instance,
  const &float4 xi,     ///< \param[in] The canonical random sample in `[0,1]^4`
  const &float3 wo,     ///< \param[in] The outgoing direction
  const &float3 wi,     ///< \param[out] The incoming direction
  const &float pdf_fwd, ///< \param[out] The PDF of sampling `wi` from `wo`
  const &float pdf_rev, ///< \param[out] The PDF of sampling `wo` from `wi`
  const &float f,       ///< \param[out] The scattering function
  const &int is_delta,  ///< \param[out] Is delta direction?
) {
  auto params = scatter_sample_parameters(
    xi: saturate(*xi),   // Guarantee clamped to [0,1]
    wo0: normalize(*wo), // Guarantee normalized
    thin_walled: instance.mat.thin_walled,
    normal: normalize(*instance.normal),
  );
  auto result = #typeof(instance.mat.backface) == #typeof(material_surface()) || !params.hit_backface //
                ? scatter_sample(&instance.mat.surface.scattering, &params)                           //
                : scatter_sample(&instance.mat.backface.scattering, &params);
  visit result in result {
    *wi = #select(params.hit_backface, -result.wi, +result.wi);
    if (result.mode == scatter_none || ((wo.z < 0) == (wi.z < 0)) != (result.mode == scatter_reflect)) {
      *pdf_fwd = 0.0;
      *pdf_rev = 0.0;
      for (int i = 0; i < $WAVELENGTH_BASE_MAX; i++)
        f[i] = 0.0;
      return false;
    }
    if ((*is_delta = bool(result.delta_f))) {
      *pdf_fwd = 1.0;
      *pdf_rev = 1.0;
      #memcpy(f, &*result.delta_f, #sizeof(float) * $WAVELENGTH_BASE_MAX);
      return true;
    } else {
      return $scatter_evaluate(instance, wo, wi, pdf_fwd, pdf_rev, f);
    }
  }
}
