// vim:foldmethod=marker:foldlevel=0:fmr=--{,--} 
#smdl

using ::math import *;
using ::monte_carlo import *;
using ::specular import *;

export enum scatter_mode {
  scatter_none = 0,
  scatter_reflect = 1,
  scatter_transmit = 2,
  scatter_reflect_transmit = 3
};

/// Calculate the chance of reflection.
@(pure macro) float scatter_reflect_chance(const scatter_mode mode) {
  const auto refl_weight(#select((int(mode) & 1) != 0, 1.0, 0.0));
  const auto tran_weight(#select((int(mode) & 2) != 0, 1.0, 0.0));
  return refl_weight / (refl_weight + tran_weight);
}

/// Calculate the orthogonal right-handed tangent space from the 
/// given normal and tangent vectors.
@(pure noinline) float3x3 build_tangent_space(
    const float3 normal, const float3 tangent_u) {
  const auto tw(normalize(normal) * #sign(normal.z));
  const auto tu(normalize(tangent_u - dot(tangent_u, tw) * tw));
  const auto tv(normalize(cross(tw, tu)));
  return float3x3(tu, tv, tw);
}

/// An arbitrary epsilon for stabilizing scattering calculations.
const float SCATTER_EPS = 0.001;

struct scatter_evaluate_parameters {
  /// The reference outgoing direction in the natural tangent space.
  float3 wo0;

  /// The reference incoming direction in the natural tangent space.
  float3 wi0;

  /// The reference mode. 
  scatter_mode mode = (wo0.z < 0) == (wi0.z < 0) ? scatter_reflect : scatter_transmit;

  /// Hit backface?
  bool hit_backface = wo0.z < 0;

  /// Is thin walled?
  bool thin_walled = false;

  /// The relative upper-to-lower index of refraction.
  float ior = 1 / 1.4;

  /// The normal direction.
  float3 normal = float3(0, 0, 1);

  /// The tangent direction.
  float3 tangent_u = float3(1, 0, 0);
  
  /// The outgoing direction.
  float3 wo = wo0;
  
  /// The incoming direction.
  float3 wi = wi0;

  finalize {
    // If we hit the backface, flip everything so that `wo` 
    // is always in the upper hemisphere.
    if (hit_backface) {
      wo0 = -wo0; 
      wi0 = -wi0;
      wo = -wo;
      wi = -wi;
      ior = 1 / ior;
    }
  }
};

@(pure noinline) bool recalculate_tangent_space(inline const &scatter_evaluate_parameters params) {
  auto tbn(build_tangent_space(normal, tangent_u));
  wo = wo0 * tbn;
  wi = wi0 * tbn;
  return ((wo.z < 0) == (wo0.z < 0)) & ((wi.z < 0) == (wi0.z < 0));
}

@(pure) float3 half_direction(inline const &scatter_evaluate_parameters params) {
  return normalize(mode == scatter_reflect ? wo + wi : refraction_half_vector(wo, wi, ior));
}

struct scatter_evaluate_result {
  /// The Bidirectional Scattering Distribution Function (BSDF) evaluation.
  auto f = 0.0;

  /// The Probability Density Function (PDF) evaluations.
  /// - `pdf[0]` is the forward density of sampling ωi given ωo.
  /// - `pdf[1]` is the reverse density of sampling ωo given ωi.
  float2 pdf = float2(0.0);

  /// Is known to be black by construction? Faster than checking every 
  /// element of `f`!
  bool is_black = false;

  finalize {
    #assert((#typeof(f) == float) |
            (#typeof(f) == color));
  }
};

struct scatter_sample_parameters {
  /// The primary outgoing direction in the natural geometric tangent space.
  float3 wo0;

  /// Hit backface?
  bool hit_backface = wo0.z < 0;

  /// Is thin walled?
  bool thin_walled = false;

  /// The active index of refraction.
  float ior = 1 / 1.4;

  /// The active normal direction.
  float3 normal = float3(0, 0, 1);

  /// The active tangent direction.
  float3 tangent_u = float3(1, 0, 0);

  /// The active outgoing direction (expanded in the active tangent space).
  float3 wo = wo0;

  /// The canonical random sample in [0,1]^4. 
  float4 xi;

  finalize {
    // If we hit the backface, flip everything so that `wo` 
    // is always in the upper hemisphere.
    if (hit_backface) {
      wo0 = -wo0;
      wo = -wo;
      ior = 1 / ior;
    }
  }
};

@(pure noinline) ?float3x3 recalculate_tangent_space(inline const &scatter_sample_parameters params) {
  auto tbn(build_tangent_space(normal, tangent_u));
  wo = wo0 * tbn;
  return tbn if ((wo.z < 0) == (wo0.z < 0));
}

struct scatter_sample_result {
  /// The sampled incoming direction.
  float3 wi = float3(0.0);

  /// The sampled scatter mode.
  scatter_mode mode = scatter_none;

  /// If sampled from a directional delta distribution, the BSDF evaluation (which is otherwise unevaluable).
  ?color delta_f = void();
};

//--{ default_bsdf
@(pure macro) auto scatter_evaluate(const &$default_bsdf this, const &scatter_evaluate_parameters params) {
  return scatter_evaluate_result(is_black: true);
}

@(pure macro) auto scatter_sample(const &$default_bsdf this, const &scatter_sample_parameters params) {
  return scatter_sample_result();
}
//--}

//--{ diffuse_reflection_bsdf
export struct diffuse_reflection_bsdf: bsdf {
  /// The tint.
  auto tint = 1.0;

  /// The roughness.
  float roughness = 0.0;

  /// The handle.
  string handle = "";

  finalize {
    #assert((#typeof(tint) == float) |
            (#typeof(tint) == color));
    roughness = saturate(roughness);
  }
};

@(pure) auto scatter_evaluate(
    inline const &diffuse_reflection_bsdf this,
    inline const &scatter_evaluate_parameters params) {
  if (mode == scatter_reflect && recalculate_tangent_space(params)) {
    const auto cos_theta(#abs(auto(wi.z, wo.z)));
    const auto pdf(cos_theta / $PI);
    if (roughness == 0) {
      return scatter_evaluate_result(f: pdf[0] * tint, pdf: pdf);
    } else {
      // Oren-Nayar terms.
      const auto sigma2(2.0 * roughness * roughness);
      const auto A(1.00 - sigma2 / (2.0 * sigma2 + 0.66));
      const auto B(0.45 * sigma2 / (sigma2 + 0.09));
      const auto fac(#max(#sum(wo.xy * wi.xy), 0) / #max_value(cos_theta));
      return scatter_evaluate_result(f: pdf[0] * (A + fac * B) * tint, pdf: pdf);
    }
  } else {
    return scatter_evaluate_result(is_black: true);
  }
}

@(pure) auto scatter_sample(
    inline const &diffuse_reflection_bsdf this,
    inline const &scatter_sample_parameters params) {
  if ((tbn := recalculate_tangent_space(params))) {
    return scatter_sample_result(wi: (*tbn) * cosine_hemisphere_sample(xi.xy), mode: scatter_reflect);
  } else {
    return scatter_sample_result(); // Reject
  }
}
//--}

//--{ diffuse_transmission_bsdf
export struct diffuse_transmission_bsdf: bsdf {
  /// The tint.
  auto tint = 1.0;

  /// The handle.
  string handle = "";

  finalize {
    #assert((#typeof(tint) == float) |
            (#typeof(tint) == color));
  }
};

@(pure) auto scatter_evaluate(
    inline const &diffuse_transmission_bsdf this,
    inline const &scatter_evaluate_parameters params) {
  if (mode == scatter_transmit && recalculate_tangent_space(params)) {
    const auto cos_theta(#abs(auto(wi.z, wo.z)));
    const auto pdf(cos_theta / $PI);
    return scatter_evaluate_result(f: tint * pdf[0], pdf: pdf);
  } else {
    return scatter_evaluate_result(is_black: true);
  }
}

@(pure) auto scatter_sample(
    inline const &diffuse_transmission_bsdf this, 
    inline const &scatter_sample_parameters params) {
  if ((tbn := recalculate_tangent_space(params))) {
    return scatter_sample_result(wi: (*tbn) * -cosine_hemisphere_sample(xi.xy), mode: scatter_transmit);
  } else {
    return scatter_sample_result(); // Reject
  }
}
//--}

//--{ tint
/// A 1-value tint.
struct tint1: bsdf, edf, hair_bsdf {
  /// The tint multiplier.
  auto tint;

  /// The base `bsdf`, `edf`, or `hair_bsdf`.
  auto base;

  finalize {
    #assert((#typeof(tint) == float) |
            (#typeof(tint) == color));
  }
};

/// A 2-value tint.
struct tint2: bsdf {
  /// The tint multiplier on reflection.
  auto reflection_tint;

  /// The tint multiplier on transmission.
  auto transmission_tint;

  /// The base `bsdf`.
  bsdf base;

  finalize {
    #assert((#typeof(reflection_tint) == float) |
            (#typeof(reflection_tint) == color));
    #assert((#typeof(transmission_tint) == float) |
            (#typeof(transmission_tint) == color));
  }
};

/// Construct 1-value tint of the given `bsdf`.
export @(pure macro) auto tint(const auto tint, const bsdf base) = tint1(tint, base);

/// Construct 1-value tint of the given `edf`.
export @(pure macro) auto tint(const auto tint, const edf base) = tint1(tint, base);

/// Construct 1-value tint of the given `hair_bsdf`.
export @(pure macro) auto tint(const auto tint, const hair_bsdf base) = tint1(tint, base);

/// Construct 2-value tint of the given `bsdf`.
export @(pure macro) auto tint(const auto reflection_tint, const auto transmission_tint, const bsdf base) =
  tint2(reflection_tint, transmission_tint, base);

@(pure macro) auto scatter_evaluate(const &tint1 this, const &scatter_evaluate_parameters params) {
  auto result(scatter_evaluate(visit &this.base, params));
  if (!result.is_black) result.f *= this.tint;
  return result;
}

@(pure macro) auto scatter_evaluate(const &tint2 this, const &scatter_evaluate_parameters params) {
  auto result(scatter_evaluate(visit &this.base, params));
  if (!result.is_black) {
    if (params.mode == scatter_reflect) {
      result.f *= this.reflection_tint;
    } else {
      result.f *= this.transmission_tint;
    }
  }
  return result;
}

@(pure macro) auto scatter_sample(const &tint1 this, const &scatter_sample_parameters params) {
  auto result(scatter_sample(visit &this.base, params));
  if ((result.mode != scatter_none) & bool(result.delta_f))
    *result.delta_f *= this.tint;
  return result;
}

@(pure macro) auto scatter_sample(const &tint2 this, const &scatter_sample_parameters params) {
  auto result(scatter_sample(visit &this.base, params));
  if ((result.mode != scatter_none) & bool(result.delta_f)) {
    if (params.mode == scatter_reflect) {
      *result.delta_f *= this.reflection_tint;
    } else {
      *result.delta_f *= this.transmission_tint;
    }
  }
  return result;
}
//--}

export @(pure macro) int $scatter_evaluate(
    const &$material_instance instance,
    const &float3 wo, 
    const &float3 wi,  
    const &float pdf_fwd, 
    const &float pdf_rev, 
    const &float f) {
  auto params(scatter_evaluate_parameters(
    wo0: normalize(*wo), // Guarantee normalized
    wi0: normalize(*wi), // Guarantee normalized
    thin_walled: instance.mat.thin_walled,
    normal: normalize(*instance.normal)));
  auto result(
    (#typeof(instance.mat.backface) == #typeof(material_surface()) || !params.hit_backface)
      ? scatter_evaluate(&instance.mat.surface.scattering, &params)
      : scatter_evaluate(&instance.mat.backface.scattering, &params));
  visit result in result {
    if (result.is_black) {
      *pdf_fwd = 0;
      *pdf_rev = 0;
      for (int i = 0; i < $WAVELENGTH_BASE_MAX; i++) 
        f[i] = 0.0;
    } else {
      *pdf_fwd = result.pdf[0];
      *pdf_rev = result.pdf[1];
      if (#typeof(result.f) == float) {
        for (int i = 0; i < $WAVELENGTH_BASE_MAX; i++) 
          f[i] = result.f;
      } else {
        #memcpy(f, &result.f, #sizeof(float) * $WAVELENGTH_BASE_MAX);
      }
    }
    return !result.is_black;
  }
}

export @(pure macro) int $scatter_sample(
    const &$material_instance instance,
    const &float4 xi,
    const &float3 wo, 
    const &float3 wi,  
    const &float pdf_fwd, 
    const &float pdf_rev, 
    const &float f,
    const &int is_delta) {
  auto params(scatter_sample_parameters(
    xi:  saturate(*xi),  // Guarantee clamped to [0,1]
    wo0: normalize(*wo), // Guarantee normalized
    thin_walled: instance.mat.thin_walled,
    normal: normalize(*instance.normal)));
  auto result(
    (#typeof(instance.mat.backface) == #typeof(material_surface()) || !params.hit_backface) 
      ? scatter_sample(&instance.mat.surface.scattering, &params)
      : scatter_sample(&instance.mat.backface.scattering, &params));
  visit result in result {
    *wi = #select(params.hit_backface, -result.wi, +result.wi);
    if (result.mode == scatter_none ||
        ((wo.z < 0) == (wi.z < 0)) != (result.mode == scatter_reflect)) {
      *pdf_fwd = 0.0;
      *pdf_rev = 0.0;
      for (int i = 0; i < $WAVELENGTH_BASE_MAX; i++)
        f[i] = 0.0;
      return false;
    }
    if ((*is_delta = bool(result.delta_f))) {
      *pdf_fwd = 1.0;
      *pdf_rev = 1.0;
      #memcpy(f, &*result.delta_f, #sizeof(float) * $WAVELENGTH_BASE_MAX);
      return true;
    } else {
      return $scatter_evaluate(instance, wo, wi, pdf_fwd, pdf_rev, f);
    }
  }
}
